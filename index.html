<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>EA88&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="见自己、见天地、见众生">
<meta property="og:type" content="website">
<meta property="og:title" content="EA88'Blog">
<meta property="og:url" content="https://github.com/Easence/index.html">
<meta property="og:site_name" content="EA88'Blog">
<meta property="og:description" content="见自己、见天地、见众生">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="EA88'Blog">
<meta name="twitter:description" content="见自己、见天地、见众生">
  
    <link rel="alternate" href="/atom.xml" title="EA88&#39;Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">EA88&#39;Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">见自己、见天地、见众生</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/Easence"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-经典排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/28/经典排序算法/" class="article-date">
  <time datetime="2016-11-28T09:21:09.000Z" itemprop="datePublished">2016-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/28/经典排序算法/">经典排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、归并排序（复杂度O-N-logN-）"><a href="#一、归并排序（复杂度O-N-logN-）" class="headerlink" title="一、归并排序（复杂度O(N*logN)）"></a>一、归并排序（复杂度O(N*logN)）</h2><h3 id="一轮合并操作"><a href="#一轮合并操作" class="headerlink" title="一轮合并操作"></a>一轮合并操作</h3><ol>
<li>存在两个<strong>有序</strong>的数组A、B合并到一个新的数组C，并让新的数组C有序。</li>
<li>取出A的第一个元素与B的第一元素比较，取出小的放入数组C中。</li>
<li>重复步骤2，直到A、B数组至少一个为空，如果A为空，则拷贝B剩余元素到C中；B为空，则拷贝A剩余元素到C中。</li>
</ol>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>采用了分治的思想，递归的将需要排序的数组对半的分成两个子数组，并对这两个数组进行合并。<strong>当被拆分的数组的元素个数小于等于1个的时候，那么这个两个子数组内部就一定是有序的，因此合并起来的数组也是有序的</strong>。接下来就是重复以上提到的“基本原理”，进行N轮的合并操作。</p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void mergesort(int a[], int first, int last, int temp[])</div><div class="line">&#123;</div><div class="line">	if (first &lt; last)</div><div class="line">	&#123;</div><div class="line">		int mid = (first + last) / 2;</div><div class="line">		mergesort(a, first, mid, temp);    //左边有序</div><div class="line">		mergesort(a, mid + 1, last, temp); //右边有序</div><div class="line">		mergearray(a, first, mid, last, temp); //再将二个有序数列合并</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二、快速排序-复杂度O-N-logN"><a href="#二、快速排序-复杂度O-N-logN" class="headerlink" title="二、快速排序(复杂度O(N*logN))"></a>二、快速排序(复杂度O(N*logN))</h2><h3 id="一轮排序操作"><a href="#一轮排序操作" class="headerlink" title="一轮排序操作"></a>一轮排序操作</h3><ol>
<li>先从数列中取出一个数作为基准数。</li>
<li>分区过程，将比这个数大的数全挖出来放到它的右边，小于或等于它的数挖出来放到它的左边。（<em>具体来说，创建两个索引l、r，遍历的过程中，l从左往右移动，r从右往左移动。当左边的元素被挖出来了，则遍历右边，直到发现右边比基准数小的数字，填到左边。当右边的元素被挖出来了，则遍历左边，直到发现左边比基准数小的数字，填到右边。</em>）</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void quick_sort1(int s[], int l, int r)</div><div class="line">&#123;</div><div class="line">	if (l &lt; r)</div><div class="line">    &#123;</div><div class="line">		int i = AdjustArray(s, l, r);//一轮排序操作</div><div class="line">		quick_sort1(s, l, i - 1); // 递归调用 </div><div class="line">		quick_sort1(s, i + 1, r);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三、堆排序-复杂度O-N-logN"><a href="#三、堆排序-复杂度O-N-logN" class="headerlink" title="三、堆排序(复杂度O(N*logN))"></a>三、堆排序(复杂度O(N*logN))</h2><p>二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：</p>
<ol>
<li>父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ol>
<p>根据这个特性我们知道<strong>堆顶的元素一定是最大或者最小</strong>。因此堆排序的步骤一般为：</p>
<ol>
<li>将无序数组A[n-1]构造成一个二叉堆，然后取出堆顶与堆尾交换。</li>
<li>此时A[n-1]是有序的，A[0…n-2]重复步骤1。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external">白话经典算法系列之六 快速排序 快速搞定</a></p>
<p><a href="http://blog.csdn.net/morewindows/article/details/6678165" target="_blank" rel="external">白话经典算法系列之五 归并排序的实现</a></p>
<p><a href="http://blog.csdn.net/morewindows/article/details/6709644" target="_blank" rel="external">白话经典算法系列之七 堆与堆排序</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/11/28/经典排序算法/" data-id="ciw6i5fkq001px704tfae19x0" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-苹果的文字系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/15/苹果的文字系统/" class="article-date">
  <time datetime="2016-11-15T02:33:17.000Z" itemprop="datePublished">2016-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS开发笔记/">iOS开发笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/15/苹果的文字系统/">苹果文字系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png" alt="文字系统架构"></p>
<h2 id="文字排版知识"><a href="#文字排版知识" class="headerlink" title="文字排版知识"></a>文字排版知识</h2><ul>
<li>首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：<br><img src="https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png" alt="两个字符对应一个字形的例子"></li>
</ul>
<ul>
<li><p>字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由<code>NSLayoutManager</code>来管理的。</p>
</li>
<li><p>字形矩阵<br><img src="https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png" alt="字形矩阵"></p>
</li>
<li><p>字距调整<br><img src="https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png" alt="kernig"></p>
</li>
<li><p>一行文字<br><img src="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png" alt="字形"><br>由上图可见：</p>
</li>
<li><p>一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。</p>
</li>
<li>LineHeight = Ascent + Descent + lineGap</li>
</ul>
<h2 id="Text-Kit"><a href="#Text-Kit" class="headerlink" title="Text Kit"></a>Text Kit</h2><p>基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：<br><img src="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png" alt="Text Kit所处位置"></p>
<h3 id="Text-Kit中的主要对象"><a href="#Text-Kit中的主要对象" class="headerlink" title="Text Kit中的主要对象"></a>Text Kit中的主要对象</h3><p><img src="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png" alt="Text Kit中的主要对象"></p>
<ul>
<li><p><strong>Text container</strong>: 通常是<code>NSTextContainer</code>对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。</p>
</li>
<li><p><strong>Layout manager</strong>:通常是<code>NSLayoutManager</code>对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。</p>
<ul>
<li>将字符跟字形进行映射。</li>
<li>根据NSTextContainer定义的区域来排版字形。</li>
</ul>
</li>
<li><p><strong>Text storage</strong>通常是<code>NSTextStorage</code>对象或者其子对象，<code>NSTextStorage</code>是<code>NSMutableAttributedString</code>的子对象，其包含多个<code>NSLayoutManager</code>，当有变动的时候，通知<code>NSLayoutManager</code>刷新</p>
</li>
<li><p><strong>对应关系</strong>： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。</p>
</li>
</ul>
<h2 id="直接绘制文字"><a href="#直接绘制文字" class="headerlink" title="直接绘制文字"></a>直接绘制文字</h2><h3 id="NSString的UIStringDrawing-category"><a href="#NSString的UIStringDrawing-category" class="headerlink" title="NSString的UIStringDrawing category"></a>NSString的UIStringDrawing category</h3><p>可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。</p>
<h3 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h3><p>CATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。</p>
<h3 id="Core-Text"><a href="#Core-Text" class="headerlink" title="Core Text"></a>Core Text</h3><ul>
<li><p>通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。</p>
</li>
<li><p>Core Text框架综合了Core Foundation以及Core Graphics。</p>
</li>
<li><p>Core Text包含两个重要的部分：layout engine以及font technology。</p>
</li>
</ul>
<h4 id="Layout-engine"><a href="#Layout-engine" class="headerlink" title="Layout engine"></a>Layout engine</h4><p>Core Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：<code>CTFramesetterRef</code>、<code>CTFrameRef</code>、<code>CTTypesetterRef</code>、<code>CTLineRef</code>、<code>CTRunRef</code>这几个对象。如下图所示：</p>
<p><img src="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png" alt=""></p>
<ul>
<li>CTFramesetterRef</li>
<li>CTFrameRef</li>
<li>CTTypesetterRef</li>
<li>CTLineRef</li>
<li>CTRunRef</li>
</ul>
<h4 id="Core-Text-Font-Opaque-Types"><a href="#Core-Text-Font-Opaque-Types" class="headerlink" title="Core Text Font Opaque Types"></a>Core Text Font Opaque Types</h4><p>通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。</p>
<ul>
<li>CTFontRef：对应UIFont</li>
<li>CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef</li>
<li>CTFontCollectionRef：</li>
</ul>
<h2 id="自定义可与键盘交互的Text-View"><a href="#自定义可与键盘交互的Text-View" class="headerlink" title="自定义可与键盘交互的Text View"></a>自定义可与键盘交互的Text View</h2><p>最重要的是要实现UIKeyInput协议。可参考apple<a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1" target="_blank" rel="external">官方文档</a>的Simple Text Input章节以及<a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1" target="_blank" rel="external">Custom Views for Data Input</a>。涉及到的对象或协议有：</p>
<ul>
<li>UIKeyInput</li>
<li>UITextInput</li>
<li>UITextPosition</li>
<li>UITextRange</li>
<li>UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举<code>UITextGranularity</code>值来表示。默认的分词器是：<code>UITextInputStringTokenizer</code>。</li>
</ul>
<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p><a href="https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE" target="_blank" rel="external">Typographical Concepts</a><br><a href="https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA" target="_blank" rel="external">Text Attributes</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i" target="_blank" rel="external">Introduction to Text Layout Programming Guide</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i" target="_blank" rel="external">Introduction to Text System Storage Layer Overview</a><br><a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1" target="_blank" rel="external">Custom Views for Data Input</a><br><a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1" target="_blank" rel="external">Lower Level Text-Handling Technologies</a></p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/11/15/苹果的文字系统/" data-id="ciw6i5fkr001rx704tbps83y0" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CoreText/">CoreText</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TheResponderChain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/27/TheResponderChain/" class="article-date">
  <time datetime="2016-10-27T09:23:51.000Z" itemprop="datePublished">2016-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a>►<a class="article-category-link" href="/categories/Apple-Development/iOS开发笔记/">iOS开发笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/27/TheResponderChain/">iOS的事件处理顺序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。</p>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><p>当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="Hit-testing returns the subview that was touched"></p>
<p>假设点击了View E。那么这个触摸事件传递的顺序是这样子的：</p>
<ol>
<li>由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。</li>
<li>由于触摸区域在C内，因此会检查它的子view D和E。</li>
<li>最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。</li>
</ol>
<h2 id="事件响应链"><a href="#事件响应链" class="headerlink" title="事件响应链"></a>事件响应链</h2><p>事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png" alt="The responder chain on iOS"></p>
<p>由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：</p>
<p><strong>view</strong> -&gt; <strong>view’superView</strong> -&gt; … -&gt; <strong>viewController</strong> -&gt; <strong>window</strong> -&gt; <strong>application</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" rel="external">Event Delivery: The Responder Chain</a></p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/10/27/TheResponderChain/" data-id="ciw6i5fjj000mx704tkpuf66m" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件响应链/">事件响应链</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-高效学习法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/23/高效学习法/" class="article-date">
  <time datetime="2016-10-23T09:26:51.000Z" itemprop="datePublished">2016-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/方法论/">方法论</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/23/高效学习法/">高效学习法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="方法来源"><a href="#方法来源" class="headerlink" title="方法来源"></a>方法来源</h2><p>本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。</p>
<h2 id="我要学什么"><a href="#我要学什么" class="headerlink" title="我要学什么"></a>我要学什么</h2><p>要学习的主题是什么，比如是摄影，还是iOS开发？</p>
<h2 id="筛选出我们想要学习的目标资源"><a href="#筛选出我们想要学习的目标资源" class="headerlink" title="筛选出我们想要学习的目标资源"></a>筛选出我们想要学习的目标资源</h2><p>互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。</p>
<h2 id="制定明确的、具体的、无二义性的目标"><a href="#制定明确的、具体的、无二义性的目标" class="headerlink" title="制定明确的、具体的、无二义性的目标"></a>制定明确的、具体的、无二义性的目标</h2><p>请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：</p>
<ul>
<li>目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。</li>
<li>将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。</li>
</ul>
<h2 id="学习任何知识都要先从全局出发"><a href="#学习任何知识都要先从全局出发" class="headerlink" title="学习任何知识都要先从全局出发"></a>学习任何知识都要先从全局出发</h2><p>当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。</p>
<h2 id="拆解成小任务"><a href="#拆解成小任务" class="headerlink" title="拆解成小任务"></a>拆解成小任务</h2><p>将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。</p>
<h2 id="专注主线知识，不要被分支知识所诱惑"><a href="#专注主线知识，不要被分支知识所诱惑" class="headerlink" title="专注主线知识，不要被分支知识所诱惑"></a>专注主线知识，不要被分支知识所诱惑</h2><p>如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在<strong>遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它</strong>。</p>
<h2 id="不只是眼睛读，手还要动"><a href="#不只是眼睛读，手还要动" class="headerlink" title="不只是眼睛读，手还要动"></a>不只是眼睛读，手还要动</h2><p>我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。</p>
<h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/10/23/高效学习法/" data-id="ciw6i5fl20023x704da5m4lor" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习方法/">学习方法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-从code7到xcode8都有哪些坑？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/22/从code7到xcode8都有哪些坑？/" class="article-date">
  <time datetime="2016-10-22T02:08:17.000Z" itemprop="datePublished">2016-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a>►<a class="article-category-link" href="/categories/Apple-Development/iOS开发笔记/">iOS开发笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/22/从code7到xcode8都有哪些坑？/">从code7到xcode8都有哪些坑?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="冲动的惩罚"><a href="#冲动的惩罚" class="headerlink" title="冲动的惩罚"></a>冲动的惩罚</h2><p>自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。</p>
<h2 id="坑与填平坑"><a href="#坑与填平坑" class="headerlink" title="坑与填平坑"></a>坑与填平坑</h2><h3 id="Storyboard"><a href="#Storyboard" class="headerlink" title="Storyboard"></a>Storyboard</h3><p>对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。</p>
<h4 id="所有UI控件的宽高设定了同一个初始值：1000。"><a href="#所有UI控件的宽高设定了同一个初始值：1000。" class="headerlink" title="所有UI控件的宽高设定了同一个初始值：1000。"></a>所有UI控件的宽高设定了同一个初始值：1000。</h4><p>在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。<br>但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：</p>
<ul>
<li><strong>将Storyboar的打开方式选择xcode7.x</strong>（在右侧Show the file inspector-&gt;interface Builder Document-&gt;open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。</li>
<li>在代码要使用UI宽高做些计算之前，调用一下<strong>layoutIfNeeded</strong>。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。</li>
</ul>
<h4 id="cornerRadius"><a href="#cornerRadius" class="headerlink" title="cornerRadius"></a>cornerRadius</h4><p>本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。</p>
<h4 id="TableView-static-cells"><a href="#TableView-static-cells" class="headerlink" title="TableView static cells"></a>TableView static cells</h4><p>当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。</p>
<h4 id="不支持iOS7，却可以提交iOS7应用"><a href="#不支持iOS7，却可以提交iOS7应用" class="headerlink" title="不支持iOS7，却可以提交iOS7应用"></a>不支持iOS7，却可以提交iOS7应用</h4><p>Xcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？</p>
<h4 id="卡卡卡"><a href="#卡卡卡" class="headerlink" title="卡卡卡"></a>卡卡卡</h4><p>最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/10/22/从code7到xcode8都有哪些坑？/" data-id="ciw6i5fk20011x704mq66fufo" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mach-O格式文件(用户态下的进程加载)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/16/Mach-O格式文件(用户态下的进程加载)/" class="article-date">
  <time datetime="2016-09-16T03:07:52.000Z" itemprop="datePublished">2016-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a>►<a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/16/Mach-O格式文件(用户态下的进程加载)/">Mach-O格式文件(用户态下的进程加载)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mach-O二进制文件"><a href="#Mach-O二进制文件" class="headerlink" title="Mach-O二进制文件"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>
<ul>
<li>魔数</li>
<li>CPU类型及其子类型</li>
<li>文件类型</li>
<li>用于加载器的“加载命令”的条数和大小</li>
<li>动态链接器的标志</li>
</ul>
<blockquote>
<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>
</blockquote>
<h2 id="Mach-O的加载命令"><a href="#Mach-O的加载命令" class="headerlink" title="Mach-O的加载命令"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>
<ul>
<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>
<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>
</ul>
</li>
<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>
<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>
<li>LC_CODE_SIGNATURE(代码签名)</li>
</ul>
<blockquote>
<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>
</blockquote>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>
<blockquote>
<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>
</blockquote>
<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>
<h3 id="共享库缓存（shared-library-cache）"><a href="#共享库缓存（shared-library-cache）" class="headerlink" title="共享库缓存（shared library cache）"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>
<blockquote>
<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>
</blockquote>
<h3 id="运行时加载"><a href="#运行时加载" class="headerlink" title="运行时加载"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>
<ul>
<li>dlopen(const char *path)</li>
<li>dlopen_preflight(const char *path)</li>
<li>dlsym(void <em>handle ,char </em>sym)</li>
<li>dladdr(char <em>addr , DL_Info </em>info)</li>
<li>dlerror()</li>
</ul>
<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>
<h3 id="弱定义的符号"><a href="#弱定义的符号" class="headerlink" title="弱定义的符号"></a>弱定义的符号</h3><ul>
<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>
<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>
</ul>
<blockquote>
<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>
</blockquote>
<h2 id="dyld的特性"><a href="#dyld的特性" class="headerlink" title="dyld的特性"></a>dyld的特性</h2><h3 id="两级命名空间"><a href="#两级命名空间" class="headerlink" title="两级命名空间"></a>两级命名空间</h3><ul>
<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>
<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>
</ul>
<h3 id="函数拦截"><a href="#函数拦截" class="headerlink" title="函数拦截"></a>函数拦截</h3><ul>
<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>
</li>
<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static const interpose_t interposing_functions[] \</div><div class="line">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class="line">        &#123;(void *)my_free , (void *)free &#125;,</div><div class="line">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class="line"></div><div class="line">// Note: Compile with GCC, not cc (important)</div><div class="line">//</div><div class="line">//</div><div class="line">// This is the expected interpose structure</div><div class="line"> typedef struct interpose_s &#123; void *new_func;</div><div class="line">			       void *orig_func; &#125; interpose_t;</div><div class="line">// Our prototypes - requires since we are putting them in </div><div class="line">//  the interposing_functions, below</div><div class="line"></div><div class="line">void *my_malloc(int size); // matches real malloc()</div><div class="line">void my_free (void *); // matches real free()</div><div class="line"></div><div class="line">// For clang, add attribute(used)</div><div class="line">static const interpose_t interposing_functions[] \ </div><div class="line">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class="line"></div><div class="line"> &#123; (void *)my_free, (void *)free &#125;,</div><div class="line"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">void *</div><div class="line">my_malloc (int size) &#123;</div><div class="line"> // In our function we have access to the real malloc() -</div><div class="line"> // and since we don’t want to mess with the heap ourselves,</div><div class="line"> // just call it</div><div class="line"> //</div><div class="line">void *returned = malloc(size);</div><div class="line">// call malloc_printf() because the real printf() calls malloc()</div><div class="line">// // internally - and would end up calling us, recursing ad infinitum</div><div class="line"></div><div class="line">  malloc_printf ( &quot;+ %p %d\n&quot;, returned, size); return (returned);</div><div class="line">&#125;</div><div class="line">void</div><div class="line">my_free (void *freed) &#123;</div><div class="line">// Free - just print the address, then call the real free()</div><div class="line"></div><div class="line"></div><div class="line">  malloc_printf ( &quot;- %p\n&quot;, freed); free(freed);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#if 0</div><div class="line">  From output 4-11:</div><div class="line"></div><div class="line"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class="line"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class="line"> ls(24346) malloc: + 0x100100020 88</div><div class="line"> ls(24346) malloc: + 0x100800000 4096</div><div class="line"> ls(24346) malloc: + 0x100801000 2160 </div><div class="line"> ls(24346) malloc: - 0x100800000 </div><div class="line"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<blockquote>
<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>
</blockquote>
<h2 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h2><ul>
<li>每一个进程都有自己私有的虚拟地址空间。</li>
<li>32位地址空间，用户态可访问整个4G的内存空间。</li>
<li>64位的地址允许高达16EB（16GGB）</li>
<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>
<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/09/16/Mach-O格式文件(用户态下的进程加载)/" data-id="ciw6i5fj7000bx704ckpyaxq8" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mach/">Mach</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Mach原语：一起以消息为媒介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/11/Mach原语：一起以消息为媒介/" class="article-date">
  <time datetime="2016-09-11T09:05:13.000Z" itemprop="datePublished">2016-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a>►<a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/11/Mach原语：一起以消息为媒介/">Mach原语：一切以消息为媒介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Mach概述"><a href="#1-Mach概述" class="headerlink" title="1. Mach概述"></a>1. Mach概述</h2><h3 id="1-1-Mach设计原则"><a href="#1-1-Mach设计原则" class="headerlink" title="1.1 Mach设计原则"></a>1.1 Mach设计原则</h3><ul>
<li>在Mach中所有东西（Task、线程、虚拟内存等））都是对象。</li>
<li>对象与对象之间通信<strong>只能</strong>通过端口收发消息。</li>
</ul>
<h3 id="1-2-Mach设计目标"><a href="#1-2-Mach设计目标" class="headerlink" title="1.2 Mach设计目标"></a>1.2 Mach设计目标</h3><p>内核为了保持极简，只做如下的事情：</p>
<ul>
<li>“控制点”或执行单元的管理。</li>
<li>线程或线程组（Task）的资源分配。</li>
<li>虚拟内存的分配和管理。</li>
<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>
</ul>
<h2 id="2-Mach消息"><a href="#2-Mach消息" class="headerlink" title="2. Mach消息"></a>2. Mach消息</h2><h3 id="2-1-简单消息"><a href="#2-1-简单消息" class="headerlink" title="2.1 简单消息"></a>2.1 简单消息</h3><p>最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">typedef	struct </div><div class="line">&#123;</div><div class="line">  mach_msg_bits_t	msgh_bits;//标志位</div><div class="line">  mach_msg_size_t	msgh_size;//大小</div><div class="line">  mach_port_t		msgh_remote_port;//目标端口（发送：接受方，接收：发送方）</div><div class="line">  mach_port_t		msgh_local_port; //源端口（发送：发送方，接收：接收方）</div><div class="line">  mach_port_name_t	msgh_voucher_port;</div><div class="line">  mach_msg_id_t		msgh_id;</div><div class="line">&#125; mach_msg_header_t; //消息头</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">        mach_msg_size_t msgh_descriptor_count;</div><div class="line">&#125; mach_msg_body_t;//消息体</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">        mach_msg_header_t       header;</div><div class="line">        mach_msg_body_t         body;</div><div class="line">&#125; mach_msg_base_t; //基本消息</div><div class="line"></div><div class="line">typedef	unsigned int mach_msg_trailer_type_t;//消息尾的类型</div><div class="line"></div><div class="line">typedef struct </div><div class="line">&#123;</div><div class="line">  mach_msg_trailer_type_t	msgh_trailer_type;</div><div class="line">  mach_msg_trailer_size_t	msgh_trailer_size;</div><div class="line">&#125; mach_msg_trailer_t; //消息尾</div></pre></td></tr></table></figure>
<h3 id="2-2-复杂消息"><a href="#2-2-复杂消息" class="headerlink" title="2.2 复杂消息"></a>2.2 复杂消息</h3><p>将消息头的标志位<code>mach_msg_bits_t</code>设置为<code>MACH_MSGH_BITS_COMPLEX</code>，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">  uint64_t			address;//数据的大小</div><div class="line">  boolean_t     		deallocate: 8;//发送之后是否接触分配</div><div class="line">  mach_msg_copy_options_t       copy: 8;//复制指令</div><div class="line">  unsigned int     		pad1: 8;</div><div class="line">  mach_msg_descriptor_type_t    type: 8;</div><div class="line">  mach_msg_size_t       	size;//数据的大小</div><div class="line">&#125; mach_msg_ool_descriptor64_t;</div></pre></td></tr></table></figure>
<h3 id="2-3-消息收发"><a href="#2-3-消息收发" class="headerlink" title="2.3 消息收发"></a>2.3 消息收发</h3><p>消息的收发在用户态都是通过如下方法进行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extern mach_msg_return_t	mach_msg(</div><div class="line">					mach_msg_header_t *msg,</div><div class="line">					mach_msg_option_t option,//可以设置为收消息还是发消息等类型</div><div class="line">					mach_msg_size_t send_size,</div><div class="line">					mach_msg_size_t rcv_size,</div><div class="line">					mach_port_name_t rcv_name,</div><div class="line">					mach_msg_timeout_t timeout,</div><div class="line">					mach_port_name_t notify);</div></pre></td></tr></table></figure>
<h3 id="2-4-端口"><a href="#2-4-端口" class="headerlink" title="2.4 端口"></a>2.4 端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">struct ipc_port &#123;</div><div class="line"></div><div class="line">	/*</div><div class="line">	 * Initial sub-structure in common with ipc_pset</div><div class="line">	 * First element is an ipc_object second is a</div><div class="line">	 * message queue</div><div class="line">	 */</div><div class="line">	struct ipc_object ip_object;</div><div class="line">	struct ipc_mqueue ip_messages;</div><div class="line"></div><div class="line">	natural_t ip_sprequests:1,	/* send-possible requests outstanding */</div><div class="line">		  ip_spimportant:1,	/* ... at least one is importance donating */</div><div class="line">		  ip_impdonation:1,	/* port supports importance donation */</div><div class="line">		  ip_tempowner:1,	/* dont give donations to current receiver */</div><div class="line">		  ip_guarded:1,         /* port guarded (use context value as guard) */</div><div class="line">		  ip_strict_guard:1,	/* Strict guarding; Prevents user manipulation of context values directly */</div><div class="line">		  ip_reserved:2,</div><div class="line">		  ip_impcount:24;	/* number of importance donations in nested queue */</div><div class="line"></div><div class="line">	union &#123;</div><div class="line">		struct ipc_space *receiver;</div><div class="line">		struct ipc_port *destination;</div><div class="line">		ipc_port_timestamp_t timestamp;</div><div class="line">	&#125; data;</div><div class="line"></div><div class="line">	union &#123;</div><div class="line">		ipc_kobject_t kobject;</div><div class="line">		ipc_importance_task_t imp_task;</div><div class="line">		uintptr_t alias;</div><div class="line">	&#125; kdata;</div><div class="line">		</div><div class="line">	struct ipc_port *ip_nsrequest;</div><div class="line">	struct ipc_port *ip_pdrequest;</div><div class="line">	struct ipc_port_request *ip_requests;</div><div class="line">	struct ipc_kmsg *ip_premsg;</div><div class="line"></div><div class="line">	mach_vm_address_t ip_context;</div><div class="line"></div><div class="line">	mach_port_mscount_t ip_mscount;</div><div class="line">	mach_port_rights_t ip_srights;</div><div class="line">	mach_port_rights_t ip_sorights;</div><div class="line"></div><div class="line">#if	MACH_ASSERT</div><div class="line">#define	IP_NSPARES		4</div><div class="line">#define	IP_CALLSTACK_MAX	16</div><div class="line">/*	queue_chain_t	ip_port_links;*//* all allocated ports */</div><div class="line">	thread_t	ip_thread;	/* who made me?  thread context */</div><div class="line">	unsigned long	ip_timetrack;	/* give an idea of &quot;when&quot; created */</div><div class="line">	uintptr_t	ip_callstack[IP_CALLSTACK_MAX]; /* stack trace */</div><div class="line">	unsigned long	ip_spares[IP_NSPARES]; /* for debugging */</div><div class="line">#endif	/* MACH_ASSERT */</div><div class="line">&#125; __attribute__((__packed__));</div></pre></td></tr></table></figure>
<h3 id="2-5-Mach接口生成器（MIG）"><a href="#2-5-Mach接口生成器（MIG）" class="headerlink" title="2.5 Mach接口生成器（MIG）"></a>2.5 Mach接口生成器（MIG）</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些<code>.defs</code>文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true" alt="IG_opt.png"></p>
<h2 id="3-深入IPC"><a href="#3-深入IPC" class="headerlink" title="3. 深入IPC"></a>3. 深入IPC</h2><ul>
<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>
<li>在用户态下，消息传递都是通过<code>mach_msg()</code>函数实现的，这个函数会触发一个mach陷阱<code>mach_msg_trap()</code>，接下来<code>mach_msg_trap()</code>又会调用<code>mach_msg_overwrite_trap()</code>，它会通过<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>来判断是发送操作，还是接收操作。</li>
<li>期中内核态中还可以通过<code>mach_msg_receive()</code>和<code>mach_msg_send()</code>来收发数据。</li>
</ul>
<h2 id="4-同步原语"><a href="#4-同步原语" class="headerlink" title="4. 同步原语"></a>4. 同步原语</h2><h3 id="4-1-锁的实现方式"><a href="#4-1-锁的实现方式" class="headerlink" title="4.1 锁的实现方式"></a>4.1 锁的实现方式</h3><ul>
<li><strong>阻塞</strong>：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。<strong>当锁可用的时候</strong>，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。</li>
<li><strong>忙等</strong>：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。</li>
<li><strong>阻塞与忙等的对比</strong>：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。</li>
</ul>
<h3 id="4-2-互斥体-lck-mtx-t-（阻塞）"><a href="#4-2-互斥体-lck-mtx-t-（阻塞）" class="headerlink" title="4.2 互斥体(lck_mtx_t)（阻塞）"></a>4.2 互斥体(lck_mtx_t)（阻塞）</h3><ul>
<li>互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。</li>
<li>原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。</li>
</ul>
<h3 id="4-3-信号量-semaphore-t-（阻塞）"><a href="#4-3-信号量-semaphore-t-（阻塞）" class="headerlink" title="4.3 信号量(semaphore_t)（阻塞）"></a>4.3 信号量(semaphore_t)（阻塞）</h3><p>信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。</p>
<h3 id="4-4-自旋锁-hw-lock-t-（忙等）"><a href="#4-4-自旋锁-hw-lock-t-（忙等）" class="headerlink" title="4.4 自旋锁(hw_lock_t)（忙等）"></a>4.4 自旋锁(hw_lock_t)（忙等）</h3><p>一种采用忙等形式的锁。</p>
<h3 id="4-5-读写锁-hw-lock-t-（阻塞）"><a href="#4-5-读写锁-hw-lock-t-（阻塞）" class="headerlink" title="4.5 读写锁(hw_lock_t)（阻塞）"></a>4.5 读写锁(hw_lock_t)（阻塞）</h3><p>当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。</p>
<h3 id="4-6-锁集-lock-set-t"><a href="#4-6-锁集-lock-set-t" class="headerlink" title="4.6 锁集(lock_set_t)"></a>4.6 锁集(lock_set_t)</h3><p>锁集就是锁的一个数组。</p>
<h2 id="5-机器原语"><a href="#5-机器原语" class="headerlink" title="5. 机器原语"></a>5. 机器原语</h2><h3 id="5-1-主机对象（Host）"><a href="#5-1-主机对象（Host）" class="headerlink" title="5.1 主机对象（Host）"></a>5.1 主机对象（Host）</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct	host &#123;</div><div class="line">	decl_lck_mtx_data(,lock)		/* lock to protect exceptions */</div><div class="line">	ipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];</div><div class="line">	struct exception_action exc_actions[EXC_TYPES_COUNT];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="5-2-时钟对象（Clock）"><a href="#5-2-时钟对象（Clock）" class="headerlink" title="5.2 时钟对象（Clock）"></a>5.2 时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是<code>clock_deadline_for_periodic_event（）</code>，调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>
<h3 id="5-3-处理器对象（Processer）"><a href="#5-3-处理器对象（Processer）" class="headerlink" title="5.3 处理器对象（Processer）"></a>5.3 处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给<strong>处理器集</strong>，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">struct processor &#123;</div><div class="line">	queue_chain_t		processor_queue;/* idle/active queue link,</div><div class="line">										 * MUST remain the first element */</div><div class="line">	int					state;			/* See below */</div><div class="line">	boolean_t		is_SMT;</div><div class="line">	boolean_t		is_recommended;</div><div class="line">	struct thread</div><div class="line">						*active_thread,	/* thread running on processor */</div><div class="line">						*next_thread,	/* next thread when dispatched */</div><div class="line">						*idle_thread;	/* this processor&apos;s idle thread. */</div><div class="line"></div><div class="line">	processor_set_t		processor_set;	/* assigned set */</div><div class="line"></div><div class="line">	int					current_pri;	/* priority of current thread */</div><div class="line">	sched_mode_t		current_thmode;	/* sched mode of current thread */</div><div class="line">	sfi_class_id_t		current_sfi_class;	/* SFI class of current thread */</div><div class="line">	int					cpu_id;			/* platform numeric id */</div><div class="line"></div><div class="line">	timer_call_data_t	quantum_timer;	/* timer for quantum expiration */</div><div class="line">	uint64_t			quantum_end;	/* time when current quantum ends */</div><div class="line">	uint64_t			last_dispatch;	/* time of last dispatch */</div><div class="line"></div><div class="line">	uint64_t			deadline;		/* current deadline */</div><div class="line">	boolean_t               first_timeslice;                /* has the quantum expired since context switch */</div><div class="line"></div><div class="line">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class="line">	struct run_queue	runq;			/* runq for this processor */</div><div class="line">#endif</div><div class="line"></div><div class="line">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class="line">	int					runq_bound_count; /* # of threads bound to this processor */</div><div class="line">#endif</div><div class="line">#if defined(CONFIG_SCHED_GRRR)</div><div class="line">	struct grrr_run_queue	grrr_runq;      /* Group Ratio Round-Robin runq */</div><div class="line">#endif</div><div class="line"></div><div class="line">	processor_t			processor_primary;	/* pointer to primary processor for</div><div class="line">											 * secondary SMT processors, or a pointer</div><div class="line">											 * to ourselves for primaries or non-SMT */</div><div class="line">	processor_t		processor_secondary;</div><div class="line">	struct ipc_port *	processor_self;	/* port for operations */</div><div class="line"></div><div class="line">	processor_t			processor_list;	/* all existing processors */</div><div class="line">	processor_data_t	processor_data;	/* per-processor data */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>
<h3 id="5-3-处理器集"><a href="#5-3-处理器集" class="headerlink" title="5.3 处理器集"></a>5.3 处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>
<ul>
<li><code>active_queue</code>：用于保存当前正在执行线程的CPU。</li>
<li><code>idle_queue</code>：用于保存当前空闲的CPU（例如：正在执行<code>idle_thread</code>）。</li>
<li><code>pset_runq</code>：保存了在这个集合中的所有CPU上执行的线程。</li>
</ul>
<p><code>processor_set</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">struct processor_set &#123;</div><div class="line">	queue_head_t		active_queue;	/* active processors */</div><div class="line">	queue_head_t		idle_queue;		/* idle processors */</div><div class="line">	queue_head_t		idle_secondary_queue;		/* idle secondary processors */</div><div class="line"></div><div class="line">	int					online_processor_count;</div><div class="line"></div><div class="line">	int					cpu_set_low, cpu_set_hi;</div><div class="line">	int					cpu_set_count;</div><div class="line"></div><div class="line">#if __SMP__</div><div class="line">	decl_simple_lock_data(,sched_lock)	/* lock for above */</div><div class="line">#endif</div><div class="line"></div><div class="line">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class="line">	struct run_queue	pset_runq;      /* runq for this processor set */</div><div class="line">#endif</div><div class="line"></div><div class="line">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class="line">	int					pset_runq_bound_count;</div><div class="line">		/* # of threads in runq bound to any processor in pset */</div><div class="line">#endif</div><div class="line"></div><div class="line">	/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</div><div class="line">	uint64_t			pending_AST_cpu_mask;</div><div class="line">#if defined(CONFIG_SCHED_DEFERRED_AST)</div><div class="line">	/*</div><div class="line">	 * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</div><div class="line">	 * some level of support for requesting an AST on a processor, and then quashing</div><div class="line">	 * that request later.</div><div class="line">	 *</div><div class="line">	 * The purpose of this field (and the associated codepaths) is to infer when we</div><div class="line">	 * no longer need a processor that is DISPATCHING to come up, and to prevent it</div><div class="line">	 * from coming out of IDLE if possible.  This should serve to decrease the number</div><div class="line">	 * of spurious ASTs in the system, and let processors spend longer periods in</div><div class="line">	 * IDLE.</div><div class="line">	 */</div><div class="line">	uint64_t			pending_deferred_AST_cpu_mask;</div><div class="line">#endif</div><div class="line"></div><div class="line">	struct ipc_port	*	pset_self;		/* port for operations */</div><div class="line">	struct ipc_port *	pset_name_self;	/* port for information */</div><div class="line"></div><div class="line">	processor_set_t		pset_list;		/* chain of associated psets */</div><div class="line">	pset_node_t			node;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/09/11/Mach原语：一起以消息为媒介/" data-id="ciw6i5fjg000jx704ez1xbx31" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mach/">Mach</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Building xnu for OS X 10.11 El Capitan" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/08/Building xnu for OS X 10.11 El Capitan/" class="article-date">
  <time datetime="2016-09-08T02:36:41.000Z" itemprop="datePublished">2016-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a>►<a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/08/Building xnu for OS X 10.11 El Capitan/">Building xnu for OS X 10.11 El Capitan</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>此文只因为国内浏览<a href="http://shantonu.blogspot.co.uk" target="_blank" rel="external">ssen’s blog</a>需要翻墙，为了方便浏览从中拷贝了一份。</em></p>
<p>The OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: <a href="https://opensource.apple.com/source/xnu/xnu-3247.1.106/" target="_blank" rel="external">here</a></p>
<p>Building xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:</p>
<ol>
<li>Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with “sudo xcodebuild -license”</li>
<li><p>Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz</div><div class="line">$ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz</div><div class="line">$ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Build and install CTF tools from dtrace</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    $ tar zxf dtrace-168.tar.gz</div><div class="line">    $ cd dtrace-168</div><div class="line">    $ mkdir -p obj sym dst</div><div class="line">    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=&quot;x86_64&quot; SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst</div><div class="line">    ...</div><div class="line">    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain</div><div class="line">    Password:</div><div class="line">    $ cd ..</div><div class="line">	```    </div><div class="line"></div><div class="line">4. Install AvailabilityVersions</div></pre></td></tr></table></figure>
<p> $ tar zxf AvailabilityVersions-20.tar.gz<br> $ cd AvailabilityVersions-20<br> $ mkdir -p dst<br> $ make install SRCROOT=$PWD DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst/usr/local <code>xcrun -sdk macosx -show-sdk-path</code>/usr/local<br> $ cd ..</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. Build xnu</div></pre></td></tr></table></figure>
<p> $ tar zxf xnu-3247.1.106.tar.gz<br> $ cd xnu-3247.1.106<br> $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**See xnu&apos;s top-level README for additional build variables that can be passed on the command-line, such as BUILD\_LTO=0 or KERNEL\_CONFIGS=DEVELOPMENT .**</div><div class="line"></div><div class="line">Update: If you are attempting to add system calls, you may also need to build Libsyscall.</div><div class="line"></div><div class="line">1. Download the Libsystem source</div></pre></td></tr></table></figure>
<p> $ curl -O <a href="https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz" target="_blank" rel="external">https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz</a></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. Install Libsystem headers</div></pre></td></tr></table></figure>
<p> $ tar zxf Libsystem-1225.1.1.tar.gz<br> $ cd Libsystem-1225.1.1<br> $ xcodebuild installhdrs -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst <code>xcrun -sdk macosx -show-sdk-path</code><br> $ cd ..</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. Install xnu and Libsyscall headers</div></pre></td></tr></table></figure>
<p> $ cd xnu-3247.1.106<br> $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst<br> $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo ditto BUILD.hdrs/dst <code>xcrun -sdk macosx -show-sdk-path</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4. Build Libsyscall</div></pre></td></tr></table></figure>
<p> $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst<br> $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).</div><div class="line"></div><div class="line">6. To install the resulting new binaries, execute:</div><div class="line">  	1. xnu:</div></pre></td></tr></table></figure>
<pre><code>$ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/
$ sudo kextcache -invalidate /
/ locked; waiting for lock.
Lock acquired; proceeding.
...
$ sudo reboot
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. Libsyscall:</div></pre></td></tr></table></figure>

$ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/
$ sudo update_dyld_shared_cache
...
$ sudo reboot
```
</code></pre></li>
</ol>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/09/08/Building xnu for OS X 10.11 El Capitan/" data-id="ciw6i5fiz0006x704r93u6xg2" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XNU/">XNU</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-由生到死--内核引导和内核崩溃" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/07/由生到死--内核引导和内核崩溃/" class="article-date">
  <time datetime="2016-09-07T12:43:53.000Z" itemprop="datePublished">2016-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a>►<a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/07/由生到死--内核引导和内核崩溃/">由生到死--内核引导和内核崩溃</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="XNU内核的编译"><a href="#XNU内核的编译" class="headerlink" title="XNU内核的编译"></a>XNU内核的编译</h2><p>参考<a href="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md">Building xnu for OS X 10.11 El Capitan</a>,但是还没有成功编译通过。。。</p>
<h2 id="一个内核，支持多种架构"><a href="#一个内核，支持多种架构" class="headerlink" title="一个内核，支持多种架构"></a>一个内核，支持多种架构</h2><ul>
<li>osfmk目录包含了架构相关的子目录（如：i386，x86_64）。</li>
<li>pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。</li>
<li>i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/platformExpert.png?raw=true" alt="pexpert结构"></li>
</ul>
<h2 id="内核代码树"><a href="#内核代码树" class="headerlink" title="内核代码树"></a>内核代码树</h2><ul>
<li>可以使用<a href="http://fxr.watson.org" target="_blank" rel="external">FXR浏览工具</a>查看源码。</li>
<li><p>XNU主目录结构：<br>  <img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true" alt="XNU主目录结构"></p>
</li>
<li><p>BSD目录结构：<br>  <img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true" alt="BSD目录结构"></p>
</li>
<li><p>OSFMK目录结构：<br>  <img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true" alt="OSFMK目录结构">    </p>
</li>
</ul>
<h2 id="XNU的引导过程"><a href="#XNU的引导过程" class="headerlink" title="XNU的引导过程"></a>XNU的引导过程</h2><p><strong>XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。</strong></p>
<h3 id="从高层次看XNU的引导过程"><a href="#从高层次看XNU的引导过程" class="headerlink" title="从高层次看XNU的引导过程"></a>从高层次看XNU的引导过程</h3><ul>
<li>整个过程如下图，后面会介绍各个阶段的细节。<br>  <img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true" alt="高层次看XNU的引导过程"></li>
<li><p><strong>OSX：vstart</strong></p>
<ul>
<li>如果是Debug环境初始化串口（pal_serial_init()）。</li>
<li>开启NX/XD：防止代码注入。</li>
<li>初始化主CPU的<a href="http://blog.csdn.net/yleek/article/details/8204393" target="_blank" rel="external">GDT和LDT</a>，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）</li>
<li>初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）</li>
<li>主从CPU调用相应的i386_init/i386_init_slave。</li>
</ul>
</li>
<li><p><strong>iOS：start</strong></p>
<p>  这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。</p>
</li>
<li><p><strong>[i386|arm]_init</strong>（osfmk/i386/i386_init.c）</p>
<p>  <em>主要工作是初始化主CPU为可用状态，然后准备好内核引导。</em></p>
</li>
<li><p><strong>i386_init_slave()</strong><br>初始化从CPU。</p>
</li>
<li><p><strong>machine_startup</strong></p>
</li>
</ul>
<p>主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。</p>
<ul>
<li><strong>kernel_bootstrap</strong><br>这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：<ul>
<li><strong>初始化虚拟内存</strong>。</li>
<li><strong>IPC（进程间通信）</strong>：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。</li>
<li><strong>时钟</strong>：通过时钟实现闹铃、报时功能。 </li>
<li><strong>账本</strong>：Mach系统的记账功能。</li>
<li><strong>任务</strong>：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。</li>
<li><strong>线程</strong>：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。<br>其中调用的重要的函数有：</li>
<li>kernel_bootstrap_thread:他的工作如下<ol>
<li>主线程开始以<code>kernel_bootstrap_thread</code>的身份运行，初始化各个子系统。</li>
<li>调用kernel_create_thread()派生辅助线程。第一个创建的线程是<strong>idle线程</strong>（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。</li>
<li>下-个创建线程就是<strong>线程调度器</strong>，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。</li>
<li>OSX的XNU启动<code>mapping_replenish线程</code>，在iOS上是<code>zone_refill_thread线程</code>。</li>
<li>如果内核设置了<strong>SERIAL_KDP</strong>,那么调度器会调用<code>init_kdp()</code>初始化调试器。</li>
<li>初始化<strong>IOKit</strong>，如果没有<strong>IOKit</strong>，XNU将无法访问硬件设备。</li>
<li>启用<strong>中断</strong>。</li>
<li>初始化<strong>共享区模块（shared region）</strong>，dyld在加载共享库时会使用这个模块，内核本身的<strong>commpage</strong>也会使用这个模块，<strong>commpage</strong>指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。</li>
<li>如果编译时启动了<strong>MAC（Mandatory Access Control）</strong>，则会调用<code>mac_policy_initmach()</code>。</li>
<li>调用<code>bsd_init</code>初始化BSD子系统，这个函数最终会派生出init任务来执行<code>bin/launchd</code>，init任务是所有用户态进程的祖先。</li>
<li>如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h2><p>睡眠流程一般如下：</p>
<ul>
<li>除了当前CPU外，停止其他的CPU。</li>
<li>关闭本地的APIC，准备进入睡眠。</li>
<li>输出一条kdebug消息。</li>
<li>在x86_64平台上保留CR3。</li>
<li>调用<code>acpi_sleep_cpu()</code>,将CPU设置为睡眠状态。</li>
<li>将控制权交给固件。</li>
</ul>
<p>唤醒处理程序的工作是：</p>
<ul>
<li>切换回64位模式。</li>
<li>恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。</li>
<li>恢复所有保存的寄存器。</li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/09/07/由生到死--内核引导和内核崩溃/" data-id="ciw6i5fki001hx704fp5095s4" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内核/">内核</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内核架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/04/内核架构/" class="article-date">
  <time datetime="2016-09-04T14:42:35.000Z" itemprop="datePublished">2016-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a>►<a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/04/内核架构/">内核架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>
<h2 id="1-内核的分类"><a href="#1-内核的分类" class="headerlink" title="1. 内核的分类"></a>1. 内核的分类</h2><h3 id="1-1-巨内核（内核空间和用户空间共享）"><a href="#1-1-巨内核（内核空间和用户空间共享）" class="headerlink" title="1.1 巨内核（内核空间和用户空间共享）"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>
<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>
<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>
</ul>
<h3 id="1-2-微内核"><a href="#1-2-微内核" class="headerlink" title="1.2 微内核"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>
<ul>
<li>正确性，得益于两点：<ol>
<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>
<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>
</ol>
</li>
<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>
</ul>
<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>
<h3 id="1-3-混合内核"><a href="#1-3-混合内核" class="headerlink" title="1.3 混合内核"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>
<h2 id="2-内核态"><a href="#2-内核态" class="headerlink" title="2. 内核态"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>
<h3 id="2-1-内核态-用户态的转换机制"><a href="#2-1-内核态-用户态的转换机制" class="headerlink" title="2.1 内核态/用户态的转换机制"></a>2.1 内核态/用户态的转换机制</h3><ul>
<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>
<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>
</ul>
<h3 id="2-2-非自愿转换"><a href="#2-2-非自愿转换" class="headerlink" title="2.2 非自愿转换"></a>2.2 非自愿转换</h3><h4 id="2-2-1-异常（Mach当中将所有异常都称作陷阱）"><a href="#2-2-1-异常（Mach当中将所有异常都称作陷阱）" class="headerlink" title="2.2.1 异常（Mach当中将所有异常都称作陷阱）"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>
<h4 id="2-2-2-中断"><a href="#2-2-2-中断" class="headerlink" title="2.2.2 中断"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>
<ul>
<li>对应的中断请求线当前不忙。</li>
<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>
<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>
</ul>
<h4 id="2-2-3-异常-中断的分发过程"><a href="#2-2-3-异常-中断的分发过程" class="headerlink" title="2.2.3 异常/中断的分发过程"></a>2.2.3 异常/中断的分发过程</h4><p><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true" alt="公共分发器"></p>
<h3 id="2-3-自愿的内核转换"><a href="#2-3-自愿的内核转换" class="headerlink" title="2.3 自愿的内核转换"></a>2.3 自愿的内核转换</h3><h4 id="2-3-1-模拟中断"><a href="#2-3-1-模拟中断" class="headerlink" title="2.3.1 模拟中断"></a>2.3.1 模拟中断</h4><h4 id="2-3-2-SYSENTER-SYSCALL"><a href="#2-3-2-SYSENTER-SYSCALL" class="headerlink" title="2.3.2 SYSENTER/SYSCALL"></a>2.3.2 SYSENTER/SYSCALL</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/Easence/2016/09/04/内核架构/" data-id="ciw6i5fjw000wx704hn58224b" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内核架构/">内核架构</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Apple-Development/">Apple Development</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Apple-Development/iOS开发笔记/">iOS开发笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Apple-Development/安全/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JS/React-Native/">React Native</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS开发笔记/">iOS开发笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/方法论/">方法论</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocoapods/">Cocoapods</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CoreText/">CoreText</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5/">H5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mach/">Mach</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XNU/">XNU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/launchd/">launchd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件响应链/">事件响应链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核架构/">内核架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习方法/">学习方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/引导过程/">引导过程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件系统/">文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cocoapods/" style="font-size: 10px;">Cocoapods</a> <a href="/tags/CoreText/" style="font-size: 10px;">CoreText</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/Mach/" style="font-size: 20px;">Mach</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/XNU/" style="font-size: 10px;">XNU</a> <a href="/tags/launchd/" style="font-size: 10px;">launchd</a> <a href="/tags/事件响应链/" style="font-size: 10px;">事件响应链</a> <a href="/tags/内核/" style="font-size: 10px;">内核</a> <a href="/tags/内核架构/" style="font-size: 10px;">内核架构</a> <a href="/tags/学习方法/" style="font-size: 15px;">学习方法</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/引导过程/" style="font-size: 10px;">引导过程</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/28/经典排序算法/">经典排序算法</a>
          </li>
        
          <li>
            <a href="/2016/11/15/苹果的文字系统/">苹果文字系统</a>
          </li>
        
          <li>
            <a href="/2016/10/27/TheResponderChain/">iOS的事件处理顺序</a>
          </li>
        
          <li>
            <a href="/2016/10/23/高效学习法/">高效学习法</a>
          </li>
        
          <li>
            <a href="/2016/10/22/从code7到xcode8都有哪些坑？/">从code7到xcode8都有哪些坑?</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 EA88<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>