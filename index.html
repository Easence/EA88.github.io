<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="If what you need didn&apos;t exist, just create it!">
<meta property="og:type" content="website">
<meta property="og:title" content="EA88'Blog">
<meta property="og:url" content="https://github.com/Easence/index.html">
<meta property="og:site_name" content="EA88'Blog">
<meta property="og:description" content="If what you need didn&apos;t exist, just create it!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="EA88'Blog">
<meta name="twitter:description" content="If what you need didn&apos;t exist, just create it!">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://github.com/Easence/"/>


  <title> EA88'Blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/avatar.jpg"
             alt="EA88'Blog"/>
      </a>
    </div>
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">EA88'Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">iOS开发者</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/Mach-O格式文件(用户态下的进程加载)/" itemprop="url">
                  Mach-O格式文件(用户态下的进程加载)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T11:07:52+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Mach-O二进制文件"><a href="#Mach-O二进制文件" class="headerlink" title="Mach-O二进制文件"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>
<ul>
<li>魔数</li>
<li>CPU类型及其子类型</li>
<li>文件类型</li>
<li>用于加载器的“加载命令”的条数和大小</li>
<li>动态链接器的标志</li>
</ul>
<blockquote>
<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>
</blockquote>
<h2 id="Mach-O的加载命令"><a href="#Mach-O的加载命令" class="headerlink" title="Mach-O的加载命令"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>
<ul>
<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>
<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>
</ul>
</li>
<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>
<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>
<li>LC_CODE_SIGNATURE(代码签名)</li>
</ul>
<blockquote>
<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>
</blockquote>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>
<blockquote>
<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>
</blockquote>
<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>
<h3 id="共享库缓存（shared-library-cache）"><a href="#共享库缓存（shared-library-cache）" class="headerlink" title="共享库缓存（shared library cache）"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>
<blockquote>
<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>
</blockquote>
<h3 id="运行时加载"><a href="#运行时加载" class="headerlink" title="运行时加载"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>
<ul>
<li>dlopen(const char *path)</li>
<li>dlopen_preflight(const char *path)</li>
<li>dlsym(void <em>handle ,char </em>sym)</li>
<li>dladdr(char <em>addr , DL_Info </em>info)</li>
<li>dlerror()</li>
</ul>
<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>
<h3 id="弱定义的符号"><a href="#弱定义的符号" class="headerlink" title="弱定义的符号"></a>弱定义的符号</h3><ul>
<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>
<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>
</ul>
<blockquote>
<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>
</blockquote>
<h2 id="dyld的特性"><a href="#dyld的特性" class="headerlink" title="dyld的特性"></a>dyld的特性</h2><h3 id="两级命名空间"><a href="#两级命名空间" class="headerlink" title="两级命名空间"></a>两级命名空间</h3><ul>
<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>
<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>
</ul>
<h3 id="函数拦截"><a href="#函数拦截" class="headerlink" title="函数拦截"></a>函数拦截</h3><ul>
<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>
</li>
<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static const interpose_t interposing_functions[] \</div><div class="line">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class="line">        &#123;(void *)my_free , (void *)free &#125;,</div><div class="line">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class="line"></div><div class="line">// Note: Compile with GCC, not cc (important)</div><div class="line">//</div><div class="line">//</div><div class="line">// This is the expected interpose structure</div><div class="line"> typedef struct interpose_s &#123; void *new_func;</div><div class="line">			       void *orig_func; &#125; interpose_t;</div><div class="line">// Our prototypes - requires since we are putting them in </div><div class="line">//  the interposing_functions, below</div><div class="line"></div><div class="line">void *my_malloc(int size); // matches real malloc()</div><div class="line">void my_free (void *); // matches real free()</div><div class="line"></div><div class="line">// For clang, add attribute(used)</div><div class="line">static const interpose_t interposing_functions[] \ </div><div class="line">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class="line"></div><div class="line"> &#123; (void *)my_free, (void *)free &#125;,</div><div class="line"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">void *</div><div class="line">my_malloc (int size) &#123;</div><div class="line"> // In our function we have access to the real malloc() -</div><div class="line"> // and since we don’t want to mess with the heap ourselves,</div><div class="line"> // just call it</div><div class="line"> //</div><div class="line">void *returned = malloc(size);</div><div class="line">// call malloc_printf() because the real printf() calls malloc()</div><div class="line">// // internally - and would end up calling us, recursing ad infinitum</div><div class="line"></div><div class="line">  malloc_printf ( &quot;+ %p %d\n&quot;, returned, size); return (returned);</div><div class="line">&#125;</div><div class="line">void</div><div class="line">my_free (void *freed) &#123;</div><div class="line">// Free - just print the address, then call the real free()</div><div class="line"></div><div class="line"></div><div class="line">  malloc_printf ( &quot;- %p\n&quot;, freed); free(freed);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#if 0</div><div class="line">  From output 4-11:</div><div class="line"></div><div class="line"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class="line"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class="line"> ls(24346) malloc: + 0x100100020 88</div><div class="line"> ls(24346) malloc: + 0x100800000 4096</div><div class="line"> ls(24346) malloc: + 0x100801000 2160 </div><div class="line"> ls(24346) malloc: - 0x100800000 </div><div class="line"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<blockquote>
<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>
</blockquote>
<h2 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h2><ul>
<li>每一个进程都有自己私有的虚拟地址空间。</li>
<li>32位地址空间，用户态可访问整个4G的内存空间。</li>
<li>64位的地址允许高达16EB（16GGB）</li>
<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>
<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>
</blockquote>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/Mach原语：一起以消息为媒介/" itemprop="url">
                  Mach原语：一起以消息为媒介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T17:05:13+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Mach概述"><a href="#1-Mach概述" class="headerlink" title="1. Mach概述"></a>1. Mach概述</h2><h3 id="1-1-Mach设计原则"><a href="#1-1-Mach设计原则" class="headerlink" title="1.1 Mach设计原则"></a>1.1 Mach设计原则</h3><ul>
<li>在Mach中所有东西（Task、线程、虚拟内存等））都是对象。</li>
<li>对象与对象之间通信<strong>只能</strong>通过端口收发消息。</li>
</ul>
<h3 id="1-2-Mach设计目标"><a href="#1-2-Mach设计目标" class="headerlink" title="1.2 Mach设计目标"></a>1.2 Mach设计目标</h3><p>内核为了保持极简，只做如下的事情：</p>
<ul>
<li>“控制点”或执行单元的管理。</li>
<li>线程或线程组（Task）的资源分配。</li>
<li>虚拟内存的分配和管理。</li>
<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>
</ul>
<h2 id="2-Mach消息"><a href="#2-Mach消息" class="headerlink" title="2. Mach消息"></a>2. Mach消息</h2><h3 id="2-1-简单消息"><a href="#2-1-简单消息" class="headerlink" title="2.1 简单消息"></a>2.1 简单消息</h3><p>最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">typedef	struct </div><div class="line">&#123;</div><div class="line">  mach_msg_bits_t	msgh_bits;//标志位</div><div class="line">  mach_msg_size_t	msgh_size;//大小</div><div class="line">  mach_port_t		msgh_remote_port;//目标端口（发送：接受方，接收：发送方）</div><div class="line">  mach_port_t		msgh_local_port; //源端口（发送：发送方，接收：接收方）</div><div class="line">  mach_port_name_t	msgh_voucher_port;</div><div class="line">  mach_msg_id_t		msgh_id;</div><div class="line">&#125; mach_msg_header_t; //消息头</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">        mach_msg_size_t msgh_descriptor_count;</div><div class="line">&#125; mach_msg_body_t;//消息体</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">        mach_msg_header_t       header;</div><div class="line">        mach_msg_body_t         body;</div><div class="line">&#125; mach_msg_base_t; //基本消息</div><div class="line"></div><div class="line">typedef	unsigned int mach_msg_trailer_type_t;//消息尾的类型</div><div class="line"></div><div class="line">typedef struct </div><div class="line">&#123;</div><div class="line">  mach_msg_trailer_type_t	msgh_trailer_type;</div><div class="line">  mach_msg_trailer_size_t	msgh_trailer_size;</div><div class="line">&#125; mach_msg_trailer_t; //消息尾</div></pre></td></tr></table></figure>
<h3 id="2-2-复杂消息"><a href="#2-2-复杂消息" class="headerlink" title="2.2 复杂消息"></a>2.2 复杂消息</h3><p>将消息头的标志位<code>mach_msg_bits_t</code>设置为<code>MACH_MSGH_BITS_COMPLEX</code>，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">  uint64_t			address;//数据的大小</div><div class="line">  boolean_t     		deallocate: 8;//发送之后是否接触分配</div><div class="line">  mach_msg_copy_options_t       copy: 8;//复制指令</div><div class="line">  unsigned int     		pad1: 8;</div><div class="line">  mach_msg_descriptor_type_t    type: 8;</div><div class="line">  mach_msg_size_t       	size;//数据的大小</div><div class="line">&#125; mach_msg_ool_descriptor64_t;</div></pre></td></tr></table></figure>
<h3 id="2-3-消息收发"><a href="#2-3-消息收发" class="headerlink" title="2.3 消息收发"></a>2.3 消息收发</h3><p>消息的收发在用户态都是通过如下方法进行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extern mach_msg_return_t	mach_msg(</div><div class="line">					mach_msg_header_t *msg,</div><div class="line">					mach_msg_option_t option,//可以设置为收消息还是发消息等类型</div><div class="line">					mach_msg_size_t send_size,</div><div class="line">					mach_msg_size_t rcv_size,</div><div class="line">					mach_port_name_t rcv_name,</div><div class="line">					mach_msg_timeout_t timeout,</div><div class="line">					mach_port_name_t notify);</div></pre></td></tr></table></figure>
<h3 id="2-4-端口"><a href="#2-4-端口" class="headerlink" title="2.4 端口"></a>2.4 端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">struct ipc_port &#123;</div><div class="line"></div><div class="line">	/*</div><div class="line">	 * Initial sub-structure in common with ipc_pset</div><div class="line">	 * First element is an ipc_object second is a</div><div class="line">	 * message queue</div><div class="line">	 */</div><div class="line">	struct ipc_object ip_object;</div><div class="line">	struct ipc_mqueue ip_messages;</div><div class="line"></div><div class="line">	natural_t ip_sprequests:1,	/* send-possible requests outstanding */</div><div class="line">		  ip_spimportant:1,	/* ... at least one is importance donating */</div><div class="line">		  ip_impdonation:1,	/* port supports importance donation */</div><div class="line">		  ip_tempowner:1,	/* dont give donations to current receiver */</div><div class="line">		  ip_guarded:1,         /* port guarded (use context value as guard) */</div><div class="line">		  ip_strict_guard:1,	/* Strict guarding; Prevents user manipulation of context values directly */</div><div class="line">		  ip_reserved:2,</div><div class="line">		  ip_impcount:24;	/* number of importance donations in nested queue */</div><div class="line"></div><div class="line">	union &#123;</div><div class="line">		struct ipc_space *receiver;</div><div class="line">		struct ipc_port *destination;</div><div class="line">		ipc_port_timestamp_t timestamp;</div><div class="line">	&#125; data;</div><div class="line"></div><div class="line">	union &#123;</div><div class="line">		ipc_kobject_t kobject;</div><div class="line">		ipc_importance_task_t imp_task;</div><div class="line">		uintptr_t alias;</div><div class="line">	&#125; kdata;</div><div class="line">		</div><div class="line">	struct ipc_port *ip_nsrequest;</div><div class="line">	struct ipc_port *ip_pdrequest;</div><div class="line">	struct ipc_port_request *ip_requests;</div><div class="line">	struct ipc_kmsg *ip_premsg;</div><div class="line"></div><div class="line">	mach_vm_address_t ip_context;</div><div class="line"></div><div class="line">	mach_port_mscount_t ip_mscount;</div><div class="line">	mach_port_rights_t ip_srights;</div><div class="line">	mach_port_rights_t ip_sorights;</div><div class="line"></div><div class="line">#if	MACH_ASSERT</div><div class="line">#define	IP_NSPARES		4</div><div class="line">#define	IP_CALLSTACK_MAX	16</div><div class="line">/*	queue_chain_t	ip_port_links;*//* all allocated ports */</div><div class="line">	thread_t	ip_thread;	/* who made me?  thread context */</div><div class="line">	unsigned long	ip_timetrack;	/* give an idea of &quot;when&quot; created */</div><div class="line">	uintptr_t	ip_callstack[IP_CALLSTACK_MAX]; /* stack trace */</div><div class="line">	unsigned long	ip_spares[IP_NSPARES]; /* for debugging */</div><div class="line">#endif	/* MACH_ASSERT */</div><div class="line">&#125; __attribute__((__packed__));</div></pre></td></tr></table></figure>
<h3 id="2-5-Mach接口生成器（MIG）"><a href="#2-5-Mach接口生成器（MIG）" class="headerlink" title="2.5 Mach接口生成器（MIG）"></a>2.5 Mach接口生成器（MIG）</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些<code>.defs</code>文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true" alt="IG_opt.png"></p>
<h2 id="3-深入IPC"><a href="#3-深入IPC" class="headerlink" title="3. 深入IPC"></a>3. 深入IPC</h2><ul>
<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>
<li>在用户态下，消息传递都是通过<code>mach_msg()</code>函数实现的，这个函数会触发一个mach陷阱<code>mach_msg_trap()</code>，接下来<code>mach_msg_trap()</code>又会调用<code>mach_msg_overwrite_trap()</code>，它会通过<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>来判断是发送操作，还是接收操作。</li>
<li>期中内核态中还可以通过<code>mach_msg_receive()</code>和<code>mach_msg_send()</code>来收发数据。</li>
</ul>
<h2 id="4-同步原语"><a href="#4-同步原语" class="headerlink" title="4. 同步原语"></a>4. 同步原语</h2><h3 id="4-1-锁的实现方式"><a href="#4-1-锁的实现方式" class="headerlink" title="4.1 锁的实现方式"></a>4.1 锁的实现方式</h3><ul>
<li><strong>阻塞</strong>：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。<strong>当锁可用的时候</strong>，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。</li>
<li><strong>忙等</strong>：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。</li>
<li><strong>阻塞与忙等的对比</strong>：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。</li>
</ul>
<h3 id="4-2-互斥体-lck-mtx-t-（阻塞）"><a href="#4-2-互斥体-lck-mtx-t-（阻塞）" class="headerlink" title="4.2 互斥体(lck_mtx_t)（阻塞）"></a>4.2 互斥体(lck_mtx_t)（阻塞）</h3><ul>
<li>互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。</li>
<li>原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。</li>
</ul>
<h3 id="4-3-信号量-semaphore-t-（阻塞）"><a href="#4-3-信号量-semaphore-t-（阻塞）" class="headerlink" title="4.3 信号量(semaphore_t)（阻塞）"></a>4.3 信号量(semaphore_t)（阻塞）</h3><p>信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。</p>
<h3 id="4-4-自旋锁-hw-lock-t-（忙等）"><a href="#4-4-自旋锁-hw-lock-t-（忙等）" class="headerlink" title="4.4 自旋锁(hw_lock_t)（忙等）"></a>4.4 自旋锁(hw_lock_t)（忙等）</h3><p>一种采用忙等形式的锁。</p>
<h3 id="4-5-读写锁-hw-lock-t-（阻塞）"><a href="#4-5-读写锁-hw-lock-t-（阻塞）" class="headerlink" title="4.5 读写锁(hw_lock_t)（阻塞）"></a>4.5 读写锁(hw_lock_t)（阻塞）</h3><p>当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。</p>
<h3 id="4-6-锁集-lock-set-t"><a href="#4-6-锁集-lock-set-t" class="headerlink" title="4.6 锁集(lock_set_t)"></a>4.6 锁集(lock_set_t)</h3><p>锁集就是锁的一个数组。</p>
<h2 id="5-机器原语"><a href="#5-机器原语" class="headerlink" title="5. 机器原语"></a>5. 机器原语</h2><h3 id="5-1-主机对象（Host）"><a href="#5-1-主机对象（Host）" class="headerlink" title="5.1 主机对象（Host）"></a>5.1 主机对象（Host）</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct	host &#123;</div><div class="line">	decl_lck_mtx_data(,lock)		/* lock to protect exceptions */</div><div class="line">	ipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];</div><div class="line">	struct exception_action exc_actions[EXC_TYPES_COUNT];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="5-2-时钟对象（Clock）"><a href="#5-2-时钟对象（Clock）" class="headerlink" title="5.2 时钟对象（Clock）"></a>5.2 时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是<code>clock_deadline_for_periodic_event（）</code>，调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>
<h3 id="5-3-处理器对象（Processer）"><a href="#5-3-处理器对象（Processer）" class="headerlink" title="5.3 处理器对象（Processer）"></a>5.3 处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给<strong>处理器集</strong>，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">struct processor &#123;</div><div class="line">	queue_chain_t		processor_queue;/* idle/active queue link,</div><div class="line">										 * MUST remain the first element */</div><div class="line">	int					state;			/* See below */</div><div class="line">	boolean_t		is_SMT;</div><div class="line">	boolean_t		is_recommended;</div><div class="line">	struct thread</div><div class="line">						*active_thread,	/* thread running on processor */</div><div class="line">						*next_thread,	/* next thread when dispatched */</div><div class="line">						*idle_thread;	/* this processor&apos;s idle thread. */</div><div class="line"></div><div class="line">	processor_set_t		processor_set;	/* assigned set */</div><div class="line"></div><div class="line">	int					current_pri;	/* priority of current thread */</div><div class="line">	sched_mode_t		current_thmode;	/* sched mode of current thread */</div><div class="line">	sfi_class_id_t		current_sfi_class;	/* SFI class of current thread */</div><div class="line">	int					cpu_id;			/* platform numeric id */</div><div class="line"></div><div class="line">	timer_call_data_t	quantum_timer;	/* timer for quantum expiration */</div><div class="line">	uint64_t			quantum_end;	/* time when current quantum ends */</div><div class="line">	uint64_t			last_dispatch;	/* time of last dispatch */</div><div class="line"></div><div class="line">	uint64_t			deadline;		/* current deadline */</div><div class="line">	boolean_t               first_timeslice;                /* has the quantum expired since context switch */</div><div class="line"></div><div class="line">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class="line">	struct run_queue	runq;			/* runq for this processor */</div><div class="line">#endif</div><div class="line"></div><div class="line">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class="line">	int					runq_bound_count; /* # of threads bound to this processor */</div><div class="line">#endif</div><div class="line">#if defined(CONFIG_SCHED_GRRR)</div><div class="line">	struct grrr_run_queue	grrr_runq;      /* Group Ratio Round-Robin runq */</div><div class="line">#endif</div><div class="line"></div><div class="line">	processor_t			processor_primary;	/* pointer to primary processor for</div><div class="line">											 * secondary SMT processors, or a pointer</div><div class="line">											 * to ourselves for primaries or non-SMT */</div><div class="line">	processor_t		processor_secondary;</div><div class="line">	struct ipc_port *	processor_self;	/* port for operations */</div><div class="line"></div><div class="line">	processor_t			processor_list;	/* all existing processors */</div><div class="line">	processor_data_t	processor_data;	/* per-processor data */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>
<h3 id="5-3-处理器集"><a href="#5-3-处理器集" class="headerlink" title="5.3 处理器集"></a>5.3 处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>
<ul>
<li><code>active_queue</code>：用于保存当前正在执行线程的CPU。</li>
<li><code>idle_queue</code>：用于保存当前空闲的CPU（例如：正在执行<code>idle_thread</code>）。</li>
<li><code>pset_runq</code>：保存了在这个集合中的所有CPU上执行的线程。</li>
</ul>
<p><code>processor_set</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">struct processor_set &#123;</div><div class="line">	queue_head_t		active_queue;	/* active processors */</div><div class="line">	queue_head_t		idle_queue;		/* idle processors */</div><div class="line">	queue_head_t		idle_secondary_queue;		/* idle secondary processors */</div><div class="line"></div><div class="line">	int					online_processor_count;</div><div class="line"></div><div class="line">	int					cpu_set_low, cpu_set_hi;</div><div class="line">	int					cpu_set_count;</div><div class="line"></div><div class="line">#if __SMP__</div><div class="line">	decl_simple_lock_data(,sched_lock)	/* lock for above */</div><div class="line">#endif</div><div class="line"></div><div class="line">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class="line">	struct run_queue	pset_runq;      /* runq for this processor set */</div><div class="line">#endif</div><div class="line"></div><div class="line">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class="line">	int					pset_runq_bound_count;</div><div class="line">		/* # of threads in runq bound to any processor in pset */</div><div class="line">#endif</div><div class="line"></div><div class="line">	/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</div><div class="line">	uint64_t			pending_AST_cpu_mask;</div><div class="line">#if defined(CONFIG_SCHED_DEFERRED_AST)</div><div class="line">	/*</div><div class="line">	 * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</div><div class="line">	 * some level of support for requesting an AST on a processor, and then quashing</div><div class="line">	 * that request later.</div><div class="line">	 *</div><div class="line">	 * The purpose of this field (and the associated codepaths) is to infer when we</div><div class="line">	 * no longer need a processor that is DISPATCHING to come up, and to prevent it</div><div class="line">	 * from coming out of IDLE if possible.  This should serve to decrease the number</div><div class="line">	 * of spurious ASTs in the system, and let processors spend longer periods in</div><div class="line">	 * IDLE.</div><div class="line">	 */</div><div class="line">	uint64_t			pending_deferred_AST_cpu_mask;</div><div class="line">#endif</div><div class="line"></div><div class="line">	struct ipc_port	*	pset_self;		/* port for operations */</div><div class="line">	struct ipc_port *	pset_name_self;	/* port for information */</div><div class="line"></div><div class="line">	processor_set_t		pset_list;		/* chain of associated psets */</div><div class="line">	pset_node_t			node;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/08/Building xnu for OS X 10.11 El Capitan/" itemprop="url">
                  Building xnu for OS X 10.11 El Capitan
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-08T10:36:41+08:00" content="2016-09-08">
              2016-09-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>此文只因为国内浏览<a href="http://shantonu.blogspot.co.uk" target="_blank" rel="external">ssen’s blog</a>需要翻墙，为了方便浏览从中拷贝了一份。</em></p>
<p>The OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: <a href="https://opensource.apple.com/source/xnu/xnu-3247.1.106/" target="_blank" rel="external">here</a></p>
<p>Building xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:</p>
<ol>
<li>Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with “sudo xcodebuild -license”</li>
<li><p>Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz</div><div class="line">$ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz</div><div class="line">$ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Build and install CTF tools from dtrace</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    $ tar zxf dtrace-168.tar.gz</div><div class="line">    $ cd dtrace-168</div><div class="line">    $ mkdir -p obj sym dst</div><div class="line">    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=&quot;x86_64&quot; SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst</div><div class="line">    ...</div><div class="line">    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain</div><div class="line">    Password:</div><div class="line">    $ cd ..</div><div class="line">	```    </div><div class="line"></div><div class="line">4. Install AvailabilityVersions</div></pre></td></tr></table></figure>
<p> $ tar zxf AvailabilityVersions-20.tar.gz<br> $ cd AvailabilityVersions-20<br> $ mkdir -p dst<br> $ make install SRCROOT=$PWD DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst/usr/local <code>xcrun -sdk macosx -show-sdk-path</code>/usr/local<br> $ cd ..</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. Build xnu</div></pre></td></tr></table></figure>
<p> $ tar zxf xnu-3247.1.106.tar.gz<br> $ cd xnu-3247.1.106<br> $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**See xnu&apos;s top-level README for additional build variables that can be passed on the command-line, such as BUILD\_LTO=0 or KERNEL\_CONFIGS=DEVELOPMENT .**</div><div class="line"></div><div class="line">Update: If you are attempting to add system calls, you may also need to build Libsyscall.</div><div class="line"></div><div class="line">1. Download the Libsystem source</div></pre></td></tr></table></figure>
<p> $ curl -O <a href="https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz" target="_blank" rel="external">https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz</a></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. Install Libsystem headers</div></pre></td></tr></table></figure>
<p> $ tar zxf Libsystem-1225.1.1.tar.gz<br> $ cd Libsystem-1225.1.1<br> $ xcodebuild installhdrs -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst <code>xcrun -sdk macosx -show-sdk-path</code><br> $ cd ..</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. Install xnu and Libsyscall headers</div></pre></td></tr></table></figure>
<p> $ cd xnu-3247.1.106<br> $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst<br> $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo ditto BUILD.hdrs/dst <code>xcrun -sdk macosx -show-sdk-path</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4. Build Libsyscall</div></pre></td></tr></table></figure>
<p> $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst<br> $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).</div><div class="line"></div><div class="line">6. To install the resulting new binaries, execute:</div><div class="line">  	1. xnu:</div></pre></td></tr></table></figure>
<pre><code>$ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/
$ sudo kextcache -invalidate /
/ locked; waiting for lock.
Lock acquired; proceeding.
...
$ sudo reboot
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. Libsyscall:</div></pre></td></tr></table></figure>

$ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/
$ sudo update_dyld_shared_cache
...
$ sudo reboot
```
</code></pre></li>
</ol>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/07/由生到死--内核引导和内核崩溃/" itemprop="url">
                  由生到死--内核引导和内核崩溃
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-07T20:43:53+08:00" content="2016-09-07">
              2016-09-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="XNU内核的编译"><a href="#XNU内核的编译" class="headerlink" title="XNU内核的编译"></a>XNU内核的编译</h2><p>参考<a href="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md">Building xnu for OS X 10.11 El Capitan</a>,但是还没有成功编译通过。。。</p>
<h2 id="一个内核，支持多种架构"><a href="#一个内核，支持多种架构" class="headerlink" title="一个内核，支持多种架构"></a>一个内核，支持多种架构</h2><ul>
<li>osfmk目录包含了架构相关的子目录（如：i386，x86_64）。</li>
<li>pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。</li>
<li>i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/platformExpert.png?raw=true" alt="pexpert结构"></li>
</ul>
<h2 id="内核代码树"><a href="#内核代码树" class="headerlink" title="内核代码树"></a>内核代码树</h2><ul>
<li>可以使用<a href="http://fxr.watson.org" target="_blank" rel="external">FXR浏览工具</a>查看源码。</li>
<li><p>XNU主目录结构：<br>  <img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true" alt="XNU主目录结构"></p>
</li>
<li><p>BSD目录结构：<br>  <img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true" alt="BSD目录结构"></p>
</li>
<li><p>OSFMK目录结构：<br>  <img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true" alt="OSFMK目录结构">    </p>
</li>
</ul>
<h2 id="XNU的引导过程"><a href="#XNU的引导过程" class="headerlink" title="XNU的引导过程"></a>XNU的引导过程</h2><p><strong>XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。</strong></p>
<h3 id="从高层次看XNU的引导过程"><a href="#从高层次看XNU的引导过程" class="headerlink" title="从高层次看XNU的引导过程"></a>从高层次看XNU的引导过程</h3><ul>
<li>整个过程如下图，后面会介绍各个阶段的细节。<br>  <img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true" alt="高层次看XNU的引导过程"></li>
<li><p><strong>OSX：vstart</strong></p>
<ul>
<li>如果是Debug环境初始化串口（pal_serial_init()）。</li>
<li>开启NX/XD：防止代码注入。</li>
<li>初始化主CPU的<a href="http://blog.csdn.net/yleek/article/details/8204393" target="_blank" rel="external">GDT和LDT</a>，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）</li>
<li>初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）</li>
<li>主从CPU调用相应的i386_init/i386_init_slave。</li>
</ul>
</li>
<li><p><strong>iOS：start</strong></p>
<p>  这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。</p>
</li>
<li><p><strong>[i386|arm]_init</strong>（osfmk/i386/i386_init.c）</p>
<p>  <em>主要工作是初始化主CPU为可用状态，然后准备好内核引导。</em></p>
</li>
<li><p><strong>i386_init_slave()</strong><br>初始化从CPU。</p>
</li>
<li><p><strong>machine_startup</strong></p>
</li>
</ul>
<p>主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。</p>
<ul>
<li><strong>kernel_bootstrap</strong><br>这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：<ul>
<li><strong>初始化虚拟内存</strong>。</li>
<li><strong>IPC（进程间通信）</strong>：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。</li>
<li><strong>时钟</strong>：通过时钟实现闹铃、报时功能。 </li>
<li><strong>账本</strong>：Mach系统的记账功能。</li>
<li><strong>任务</strong>：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。</li>
<li><strong>线程</strong>：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。<br>其中调用的重要的函数有：</li>
<li>kernel_bootstrap_thread:他的工作如下<ol>
<li>主线程开始以<code>kernel_bootstrap_thread</code>的身份运行，初始化各个子系统。</li>
<li>调用kernel_create_thread()派生辅助线程。第一个创建的线程是<strong>idle线程</strong>（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。</li>
<li>下-个创建线程就是<strong>线程调度器</strong>，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。</li>
<li>OSX的XNU启动<code>mapping_replenish线程</code>，在iOS上是<code>zone_refill_thread线程</code>。</li>
<li>如果内核设置了<strong>SERIAL_KDP</strong>,那么调度器会调用<code>init_kdp()</code>初始化调试器。</li>
<li>初始化<strong>IOKit</strong>，如果没有<strong>IOKit</strong>，XNU将无法访问硬件设备。</li>
<li>启用<strong>中断</strong>。</li>
<li>初始化<strong>共享区模块（shared region）</strong>，dyld在加载共享库时会使用这个模块，内核本身的<strong>commpage</strong>也会使用这个模块，<strong>commpage</strong>指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。</li>
<li>如果编译时启动了<strong>MAC（Mandatory Access Control）</strong>，则会调用<code>mac_policy_initmach()</code>。</li>
<li>调用<code>bsd_init</code>初始化BSD子系统，这个函数最终会派生出init任务来执行<code>bin/launchd</code>，init任务是所有用户态进程的祖先。</li>
<li>如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h2><p>睡眠流程一般如下：</p>
<ul>
<li>除了当前CPU外，停止其他的CPU。</li>
<li>关闭本地的APIC，准备进入睡眠。</li>
<li>输出一条kdebug消息。</li>
<li>在x86_64平台上保留CR3。</li>
<li>调用<code>acpi_sleep_cpu()</code>,将CPU设置为睡眠状态。</li>
<li>将控制权交给固件。</li>
</ul>
<p>唤醒处理程序的工作是：</p>
<ul>
<li>切换回64位模式。</li>
<li>恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。</li>
<li>恢复所有保存的寄存器。</li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/内核架构/" itemprop="url">
                  内核架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T22:42:35+08:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>
<h2 id="1-内核的分类"><a href="#1-内核的分类" class="headerlink" title="1. 内核的分类"></a>1. 内核的分类</h2><h3 id="1-1-巨内核（内核空间和用户空间共享）"><a href="#1-1-巨内核（内核空间和用户空间共享）" class="headerlink" title="1.1 巨内核（内核空间和用户空间共享）"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>
<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>
<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>
</ul>
<h3 id="1-2-微内核"><a href="#1-2-微内核" class="headerlink" title="1.2 微内核"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>
<ul>
<li>正确性，得益于两点：<ol>
<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>
<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>
</ol>
</li>
<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>
</ul>
<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>
<h3 id="1-3-混合内核"><a href="#1-3-混合内核" class="headerlink" title="1.3 混合内核"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>
<h2 id="2-内核态"><a href="#2-内核态" class="headerlink" title="2. 内核态"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>
<h3 id="2-1-内核态-用户态的转换机制"><a href="#2-1-内核态-用户态的转换机制" class="headerlink" title="2.1 内核态/用户态的转换机制"></a>2.1 内核态/用户态的转换机制</h3><ul>
<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>
<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>
</ul>
<h3 id="2-2-非自愿转换"><a href="#2-2-非自愿转换" class="headerlink" title="2.2 非自愿转换"></a>2.2 非自愿转换</h3><h4 id="2-2-1-异常（Mach当中将所有异常都称作陷阱）"><a href="#2-2-1-异常（Mach当中将所有异常都称作陷阱）" class="headerlink" title="2.2.1 异常（Mach当中将所有异常都称作陷阱）"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>
<h4 id="2-2-2-中断"><a href="#2-2-2-中断" class="headerlink" title="2.2.2 中断"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>
<ul>
<li>对应的中断请求线当前不忙。</li>
<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>
<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>
</ul>
<h4 id="2-2-3-异常-中断的分发过程"><a href="#2-2-3-异常-中断的分发过程" class="headerlink" title="2.2.3 异常/中断的分发过程"></a>2.2.3 异常/中断的分发过程</h4><p><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true" alt="公共分发器"></p>
<h3 id="2-3-自愿的内核转换"><a href="#2-3-自愿的内核转换" class="headerlink" title="2.3 自愿的内核转换"></a>2.3 自愿的内核转换</h3><h4 id="2-3-1-模拟中断"><a href="#2-3-1-模拟中断" class="headerlink" title="2.3.1 模拟中断"></a>2.3.1 模拟中断</h4><h4 id="2-3-2-SYSENTER-SYSCALL"><a href="#2-3-2-SYSENTER-SYSCALL" class="headerlink" title="2.3.2 SYSENTER/SYSCALL"></a>2.3.2 SYSENTER/SYSCALL</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/贯穿始终-launchd/" itemprop="url">
                  贯穿始终-launchd
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T21:22:44+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="launchd"><a href="#launchd" class="headerlink" title="launchd"></a>launchd</h2><p>launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。<br>launchd分为两种类型的后台作业：</p>
<ul>
<li><strong>守护程序</strong>（daemon），不可和用户交互。</li>
<li><strong>代理程序</strong>（agent），特殊的守护程序，可以和用户交互。</li>
</ul>
<h2 id="launchd的职责"><a href="#launchd的职责" class="headerlink" title="launchd的职责"></a>launchd的职责</h2><h3 id="运行定时作业"><a href="#运行定时作业" class="headerlink" title="运行定时作业"></a>运行定时作业</h3><p>指定时间运行指定的命令。</p>
<h3 id="启动网络服务"><a href="#启动网络服务" class="headerlink" title="启动网络服务"></a>启动网络服务</h3><p>绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。</p>
<h3 id="提供自举服务"><a href="#提供自举服务" class="headerlink" title="提供自举服务"></a>提供自举服务<servers bootstrap.h=""></servers></h3><ul>
<li>launchd在启动的时候声明一个端口（<strong>bootstrap_port</strong>）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个<strong>bootstrap_port</strong>来访问自举服务器来查询某个服务，并且匹配服务程序的端口。</li>
<li>如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers bootstrap.h="">中定义的函数<code>bootstrap_check_in()</code>来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。</servers></li>
</ul>
<h3 id="事物支持"><a href="#事物支持" class="headerlink" title="事物支持"></a>事物支持</h3><p><code>vproc_transaction_begi</code>n和<code>vproc_transaction_end</code>之间的操作称为<strong>未决事物</strong>，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。</p>
<h3 id="资源限制和遏制"><a href="#资源限制和遏制" class="headerlink" title="资源限制和遏制"></a>资源限制和遏制</h3><p>iOS Jetsam机制，可以强制施行虚拟内存使用率限制。</p>
<h3 id="Autorun模拟和文件系统观察"><a href="#Autorun模拟和文件系统观察" class="headerlink" title="Autorun模拟和文件系统观察"></a>Autorun模拟和文件系统观察</h3><ul>
<li>launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。</li>
<li>通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。</li>
</ul>
<h3 id="整合了I-O-Kit"><a href="#整合了I-O-Kit" class="headerlink" title="整合了I/O Kit"></a>整合了I/O Kit</h3><h2 id="iOS的launchDeamon"><a href="#iOS的launchDeamon" class="headerlink" title="iOS的launchDeamon"></a>iOS的launchDeamon</h2><p>iOS包含的launchDeamon列表如下图所示：<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true" alt="launchDeamon"></p>
<p><strong>其中最重要的两个守护进程是lockdownd和SpringBoard</strong></p>
<h3 id="lockdownd"><a href="#lockdownd" class="headerlink" title="lockdownd"></a>lockdownd</h3><p>lockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。</p>
<h3 id="SpringBoard"><a href="#SpringBoard" class="headerlink" title="SpringBoard"></a>SpringBoard</h3><ul>
<li>创建GUI</li>
<li>处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。</li>
<li>SpringBoard包含大量的线程，比如：<ul>
<li>有Web相关的线程（WebCore和WebThread）</li>
<li>WiFiManager</li>
<li>CoreAnimation</li>
</ul>
</li>
<li>SpringBoard通过launchd注册了很多Mach端口，其中最重要的是<code>PurpleSystemEventPort</code>，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。</li>
</ul>
<h2 id="XPC"><a href="#XPC" class="headerlink" title="XPC"></a>XPC</h2><ul>
<li>XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xpc_connection_send_message</div><div class="line">(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xpc_connection_send_barrier</div><div class="line">(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xpc_connection_send_message_with_reply</div><div class="line">(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xpc_object_t</div><div class="line">xpc_connection_send_message_with_reply_sync</div><div class="line">(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value</div></pre></td></tr></table></figure>
<ul>
<li>XPC的例子可以参照：苹果官方的<a href="https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2" target="_blank" rel="external">SandboxedFetch</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/iOS支持懒加载的PageViewController/" itemprop="url">
                  iOS支持懒加载的PageViewController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T00:12:18+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/iOS开发笔记/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这个控件包含两个部分：</p>
<ul>
<li>TWPageViewController（底部主体部分）</li>
<li>TWPageTitleViewController（顶部标题部分）</li>
</ul>
<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href="https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>
<p><img src="https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true" alt="效果图1"></p>
<p><img src="https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true" alt="效果图2"></p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><ul>
<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>直接拷贝源码到自己的工程目录。</p>
</li>
</ul>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="TWPageViewController"><a href="#TWPageViewController" class="headerlink" title="TWPageViewController"></a>TWPageViewController</h2><h3 id="为什么要写这么一个PageViewController"><a href="#为什么要写这么一个PageViewController" class="headerlink" title="为什么要写这么一个PageViewController"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>
<ul>
<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>
<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>
</ul>
<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>
<p>TWPageViewController实现了以下几个特性：</p>
<h5 id="支持UI部分的复用"><a href="#支持UI部分的复用" class="headerlink" title="支持UI部分的复用"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>
<h5 id="实现了懒加载"><a href="#实现了懒加载" class="headerlink" title="实现了懒加载"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>
<h5 id="控制了内存的增长"><a href="#控制了内存的增长" class="headerlink" title="控制了内存的增长"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>
<h5 id="跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数"><a href="#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数" class="headerlink" title="跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>
<h5 id="提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作"><a href="#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作" class="headerlink" title=" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class="line"></div><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class="line"></div><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class="line"></div><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class="line"></div><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>
<h2 id="TWPageTitleViewController"><a href="#TWPageTitleViewController" class="headerlink" title="TWPageTitleViewController"></a>TWPageTitleViewController</h2><ul>
<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>
<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class="line">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class="line">indicatorView.alpha = 0.3;</div><div class="line">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class="line">indicatorView.layer.masksToBounds = YES;</div><div class="line">indicatorView.layer.borderWidth = 1;</div><div class="line">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class="line"></div><div class="line">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>
<h2 id="计划优化的地方"><a href="#计划优化的地方" class="headerlink" title="计划优化的地方"></a>计划优化的地方</h2><ul>
<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href="https://github.com/Easence/TWPageViewController">这里</a>。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/01/引导过程：EFI和iBoot/" itemprop="url">
                  引导过程：EFI和iBoot
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-01T09:17:21+08:00" content="2016-09-01">
              2016-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是引导过程"><a href="#什么是引导过程" class="headerlink" title="什么是引导过程"></a>什么是引导过程</h2><p>引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：</p>
<ol>
<li>刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。</li>
<li>接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到<code>操作系统加载器</code>。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。</li>
<li>由操作系统加载器加载操作系统代码。</li>
</ol>
<h2 id="EFI（Extensible-Firmware-Interface，可扩展固件接口）"><a href="#EFI（Extensible-Firmware-Interface，可扩展固件接口）" class="headerlink" title="EFI（Extensible Firmware Interface，可扩展固件接口）"></a>EFI（Extensible Firmware Interface，可扩展固件接口）</h2><h3 id="BIOS的局限性"><a href="#BIOS的局限性" class="headerlink" title="BIOS的局限性"></a>BIOS的局限性</h3><ul>
<li>BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。</li>
<li>只允许4个可引导分区（或称为主分区）。</li>
</ul>
<h3 id="EFI的概念"><a href="#EFI的概念" class="headerlink" title="EFI的概念"></a>EFI的概念</h3><p>正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。</p>
<blockquote>
<p>EFI自下而上的架构大概是：硬件-&gt;固件（包含：EFI引导服务和EFI运行时服务）-&gt;EFI二进制文件（EFI引导加载器）-&gt;软件</p>
</blockquote>
<h3 id="EFI提供的服务"><a href="#EFI提供的服务" class="headerlink" title="EFI提供的服务"></a>EFI提供的服务</h3><h4 id="EFI引导服务"><a href="#EFI引导服务" class="headerlink" title="EFI引导服务"></a>EFI引导服务</h4><p>当系统仍然在EFI环境中，并且没有调用<code>ExitBootServices()</code>这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了<code>ExitBootServices()</code>,引导服务就无法访问了。</p>
<p>对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：</p>
<ul>
<li><strong>控制台协议</strong>（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）</li>
<li><strong>媒介访问</strong>（和文件系统打交道）</li>
<li><strong>杂项协议</strong>（）</li>
</ul>
<h4 id="EFI运行时服务"><a href="#EFI运行时服务" class="headerlink" title="EFI运行时服务"></a>EFI运行时服务</h4><p>跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：</p>
<ul>
<li>时间管理</li>
<li>闹钟</li>
<li>固件变量</li>
<li>其他杂项</li>
</ul>
<h2 id="OS-X的boot-efi"><a href="#OS-X的boot-efi" class="headerlink" title="OS X的boot.efi"></a>OS X的boot.efi</h2><ol>
<li>调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。</li>
<li>引导内核，EFI引导服务退出。</li>
<li>内核回调EFI运行时服务。</li>
</ol>
<h2 id="iOS的iBoot"><a href="#iOS的iBoot" class="headerlink" title="iOS的iBoot"></a>iOS的iBoot</h2><p>iOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：</p>
<ul>
<li><strong>普通引导、恢复模式引导</strong></li>
<li><strong>DFU模式引导</strong></li>
</ul>
<p><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true" alt="图1"></p>
<p>整个引导过程大概是这样的：</p>
<ol>
<li>首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)</li>
<li>接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。</li>
<li>普通引导或恢复模式引导：<ul>
<li>加载LLB（Low level Bootloader，底层引导加载器。</li>
<li>加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 </li>
</ul>
</li>
<li>DFU模式引导，使用了两个镜像iBSS和iBEC。<ul>
<li>iBSS：负责底层初始化以及iBEC的加载。</li>
<li>iBEC：负责iTunes通过USB升级的过程。</li>
</ul>
</li>
</ol>
<h3 id="普通引导或恢复模式引导"><a href="#普通引导或恢复模式引导" class="headerlink" title="普通引导或恢复模式引导"></a>普通引导或恢复模式引导</h3><h4 id="LLB"><a href="#LLB" class="headerlink" title="LLB"></a>LLB</h4><p>它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。</p>
<h4 id="iBoot"><a href="#iBoot" class="headerlink" title="iBoot"></a>iBoot</h4><p>iBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：</p>
<ul>
<li><strong>“main”线程</strong>，负责苹果的logo，以及系统的引导。</li>
<li><strong>“uart reader”线程</strong>，这个线程用户调试用。</li>
</ul>
<p>正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入<strong>恢复模式</strong>，main线程会派生几下几个任务：</p>
<ul>
<li><strong>idleoff任务</strong>，当用户不操作时，关闭设备。</li>
<li><strong>poweroff任务</strong>，当电量不足的时候，关闭设备。</li>
<li><strong>usb-req任务</strong>，处理iTunes的USB请求。</li>
<li><strong>usb-high-current和usb-no-current任务</strong>，响应USB充电。（当设备充电或者断开充电，修改电池图标）</li>
<li><strong>command任务</strong>,启动命令行接口，即通过串口操作的控制台。</li>
</ul>
<h4 id="恢复模式引导与普通引导的区别"><a href="#恢复模式引导与普通引导的区别" class="headerlink" title="恢复模式引导与普通引导的区别"></a>恢复模式引导与普通引导的区别</h4><p>恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。</p>
<h3 id="DFU模式引导"><a href="#DFU模式引导" class="headerlink" title="DFU模式引导"></a>DFU模式引导</h3><p>再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。</p>
<h2 id="OS-X的安装过程"><a href="#OS-X的安装过程" class="headerlink" title="OS X的安装过程"></a>OS X的安装过程</h2><h3 id="步骤1：installXXX-app"><a href="#步骤1：installXXX-app" class="headerlink" title="步骤1：installXXX.app"></a>步骤1：installXXX.app</h3><p>安装包包含的文件如下图所示：<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true" alt="图2"><br>运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作<code>根文件系统</code>的镜像–BaseSystem.dmg，然后通过<code>bless</code>命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。</p>
<h3 id="步骤2：OSInstaller"><a href="#步骤2：OSInstaller" class="headerlink" title="步骤2：OSInstaller"></a>步骤2：OSInstaller</h3><p>引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。</p>
<h3 id="步骤3：安装-pkg文件"><a href="#步骤3：安装-pkg文件" class="headerlink" title="步骤3：安装.pkg文件"></a>步骤3：安装.pkg文件</h3><p>最后就是安装各种各样的软件包了。</p>
<h2 id="iOS文件系统镜像（-ipsw文件）"><a href="#iOS文件系统镜像（-ipsw文件）" class="headerlink" title="iOS文件系统镜像（.ipsw文件）"></a>iOS文件系统镜像（.ipsw文件）</h2><p>将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/ipsw.png?raw=true" alt="图3"></p>
<blockquote>
<p>可以使用工具<a href="http://theiphonewiki.com/" target="_blank" rel="external">wpwntool</a>解密文件，使用<a href="http://theiphonewiki.com/" target="_blank" rel="external">vfdecrypt</a>解密系统镜像。</p>
</blockquote>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/30/Mach调度/" itemprop="url">
                  读书笔记之Mach调度
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-30T10:12:09+08:00" content="2016-08-30">
              2016-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是个结构体</p>
<h2 id="任务（task）"><a href="#任务（task）" class="headerlink" title="任务（task）"></a>任务（task）</h2><p>线程的容器，是以线程为元素的数组</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h2 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h2><p>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>
<h2 id="续体"><a href="#续体" class="headerlink" title="续体"></a>续体</h2><p>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>
<h2 id="抢占模式"><a href="#抢占模式" class="headerlink" title="抢占模式"></a>抢占模式</h2><ul>
<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>
<li>隐式抢占：调度器管理线程的执行。<h2 id="异步软件陷阱（AST）"><a href="#异步软件陷阱（AST）" class="headerlink" title="异步软件陷阱（AST）"></a>异步软件陷阱（AST）</h2></li>
</ul>
<h2 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h2><p>软件定时器：<br>硬件定时器：</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>
<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/30/文件系统和虚拟文件系统交换（VFS）/" itemprop="url">
                  文件系统和虚拟文件系统交换（VFS）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-30T10:11:37+08:00" content="2016-08-30">
              2016-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Apple Development</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入解析Mac OS X && iOS操作系统笔记</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/" itemprop="url" rel="index">
                    <span itemprop="name">内核</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h2><h3 id="主引导记录（Master-Boot-Record，MBR）"><a href="#主引导记录（Master-Boot-Record，MBR）" class="headerlink" title="主引导记录（Master Boot Record，MBR）"></a>主引导记录（Master Boot Record，MBR）</h3><ul>
<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>
</ul>
<h3 id="Apple-Partion-Map"><a href="#Apple-Partion-Map" class="headerlink" title="Apple Partion Map"></a>Apple Partion Map</h3><ul>
<li>32位方案，突破了4个分区的限制</li>
</ul>
<h3 id="GUID分区表（GUID-Partion-Table，GPT）"><a href="#GUID分区表（GUID-Partion-Table，GPT）" class="headerlink" title="GUID分区表（GUID Partion Table，GPT）"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>
<li>64位方案</li>
</ul>
<h2 id="软链接与硬链接"><a href="#软链接与硬链接" class="headerlink" title="软链接与硬链接"></a>软链接与硬链接</h2><ul>
<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>
<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>
<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="EA88" />
          <p class="site-author-name" itemprop="name">EA88</p>
          <p class="site-description motion-element" itemprop="description">If what you need didn't exist, just create it!</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Easence" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/EA_Huang" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EA88</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
