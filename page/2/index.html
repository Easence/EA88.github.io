<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://github.com/Easence">
  <title>EA88&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="见自己、见天地、见众生">
<meta property="og:type" content="website">
<meta property="og:title" content="EA88'Blog">
<meta property="og:url" content="https://github.com/Easence/page/2/index.html">
<meta property="og:site_name" content="EA88'Blog">
<meta property="og:description" content="见自己、见天地、见众生">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="EA88'Blog">
<meta name="twitter:description" content="见自己、见天地、见众生">
  
    <link rel="alternative" href="/atom.xml" title="EA88&#39;Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">EA88</a></h1>
		</hgroup>

		
		<p class="header-subtitle">见自己、见天地、见众生</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">EA88</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="null" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">EA88</h1>
			</hgroup>
			
			<p class="header-subtitle">见自己、见天地、见众生</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-贯穿始终-launchd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/02/贯穿始终-launchd/">贯穿始终-launchd</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="launchd"><a href="#launchd" class="headerlink" title="launchd"></a>launchd</h2><p>launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。<br>launchd分为两种类型的后台作业：</p>
<ul>
<li><strong>守护程序</strong>（daemon），不可和用户交互。</li>
<li><strong>代理程序</strong>（agent），特殊的守护程序，可以和用户交互。</li>
</ul>
<h2 id="launchd的职责"><a href="#launchd的职责" class="headerlink" title="launchd的职责"></a>launchd的职责</h2><h3 id="运行定时作业"><a href="#运行定时作业" class="headerlink" title="运行定时作业"></a>运行定时作业</h3><p>指定时间运行指定的命令。</p>
<h3 id="启动网络服务"><a href="#启动网络服务" class="headerlink" title="启动网络服务"></a>启动网络服务</h3><p>绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。</p>
<h3 id="提供自举服务"><a href="#提供自举服务" class="headerlink" title="提供自举服务"></a>提供自举服务<servers bootstrap.h=""></servers></h3><ul>
<li>launchd在启动的时候声明一个端口（<strong>bootstrap_port</strong>）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个<strong>bootstrap_port</strong>来访问自举服务器来查询某个服务，并且匹配服务程序的端口。</li>
<li>如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers bootstrap.h="">中定义的函数<code>bootstrap_check_in()</code>来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。</servers></li>
</ul>
<h3 id="事物支持"><a href="#事物支持" class="headerlink" title="事物支持"></a>事物支持</h3><p><code>vproc_transaction_begi</code>n和<code>vproc_transaction_end</code>之间的操作称为<strong>未决事物</strong>，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。</p>
<h3 id="资源限制和遏制"><a href="#资源限制和遏制" class="headerlink" title="资源限制和遏制"></a>资源限制和遏制</h3><p>iOS Jetsam机制，可以强制施行虚拟内存使用率限制。</p>
<h3 id="Autorun模拟和文件系统观察"><a href="#Autorun模拟和文件系统观察" class="headerlink" title="Autorun模拟和文件系统观察"></a>Autorun模拟和文件系统观察</h3><ul>
<li>launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。</li>
<li>通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。</li>
</ul>
<h3 id="整合了I-O-Kit"><a href="#整合了I-O-Kit" class="headerlink" title="整合了I/O Kit"></a>整合了I/O Kit</h3><h2 id="iOS的launchDeamon"><a href="#iOS的launchDeamon" class="headerlink" title="iOS的launchDeamon"></a>iOS的launchDeamon</h2><p>iOS包含的launchDeamon列表如下图所示：<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true" alt="launchDeamon"></p>
<p><strong>其中最重要的两个守护进程是lockdownd和SpringBoard</strong></p>
<h3 id="lockdownd"><a href="#lockdownd" class="headerlink" title="lockdownd"></a>lockdownd</h3><p>lockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。</p>
<h3 id="SpringBoard"><a href="#SpringBoard" class="headerlink" title="SpringBoard"></a>SpringBoard</h3><ul>
<li>创建GUI</li>
<li>处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。</li>
<li>SpringBoard包含大量的线程，比如：<ul>
<li>有Web相关的线程（WebCore和WebThread）</li>
<li>WiFiManager</li>
<li>CoreAnimation</li>
</ul>
</li>
<li>SpringBoard通过launchd注册了很多Mach端口，其中最重要的是<code>PurpleSystemEventPort</code>，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。</li>
</ul>
<h2 id="XPC"><a href="#XPC" class="headerlink" title="XPC"></a>XPC</h2><ul>
<li>XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xpc_connection_send_message</div><div class="line">(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xpc_connection_send_barrier</div><div class="line">(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xpc_connection_send_message_with_reply</div><div class="line">(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xpc_object_t</div><div class="line">xpc_connection_send_message_with_reply_sync</div><div class="line">(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value</div></pre></td></tr></table></figure>
<ul>
<li>XPC的例子可以参照：苹果官方的<a href="https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2" target="_blank" rel="external">SandboxedFetch</a></li>
</ul>
<hr>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/02/贯穿始终-launchd/" class="archive-article-date">
  	<time datetime="2016-09-02T13:22:44.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-02</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/launchd/">launchd</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a><a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-iOS支持懒加载的PageViewController" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/02/iOS支持懒加载的PageViewController/">iOS支持懒加载的PageViewController</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这个控件包含两个部分：</p>
<ul>
<li>TWPageViewController（底部主体部分）</li>
<li>TWPageTitleViewController（顶部标题部分）</li>
</ul>
<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href="https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>
<p><img src="https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true" alt="效果图1"></p>
<p><img src="https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true" alt="效果图2"></p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><ul>
<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>直接拷贝源码到自己的工程目录。</p>
</li>
</ul>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="TWPageViewController"><a href="#TWPageViewController" class="headerlink" title="TWPageViewController"></a>TWPageViewController</h2><h3 id="为什么要写这么一个PageViewController"><a href="#为什么要写这么一个PageViewController" class="headerlink" title="为什么要写这么一个PageViewController"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>
<ul>
<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>
<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>
</ul>
<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>
<p>TWPageViewController实现了以下几个特性：</p>
<h5 id="支持UI部分的复用"><a href="#支持UI部分的复用" class="headerlink" title="支持UI部分的复用"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>
<h5 id="实现了懒加载"><a href="#实现了懒加载" class="headerlink" title="实现了懒加载"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>
<h5 id="控制了内存的增长"><a href="#控制了内存的增长" class="headerlink" title="控制了内存的增长"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>
<h5 id="跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数"><a href="#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数" class="headerlink" title="跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>
<h5 id="提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作"><a href="#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作" class="headerlink" title=" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class="line"></div><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class="line"></div><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class="line"></div><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class="line"></div><div class="line">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>
<h2 id="TWPageTitleViewController"><a href="#TWPageTitleViewController" class="headerlink" title="TWPageTitleViewController"></a>TWPageTitleViewController</h2><ul>
<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>
<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class="line">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class="line">indicatorView.alpha = 0.3;</div><div class="line">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class="line">indicatorView.layer.masksToBounds = YES;</div><div class="line">indicatorView.layer.borderWidth = 1;</div><div class="line">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class="line"></div><div class="line">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>
<h2 id="计划优化的地方"><a href="#计划优化的地方" class="headerlink" title="计划优化的地方"></a>计划优化的地方</h2><ul>
<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href="https://github.com/Easence/TWPageViewController">这里</a>。</p>
<hr>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/02/iOS支持懒加载的PageViewController/" class="archive-article-date">
  	<time datetime="2016-09-01T16:12:18.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-02</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a><a class="article-category-link" href="/categories/Apple-Development/iOS开发笔记/">iOS开发笔记</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-引导过程：EFI和iBoot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/01/引导过程：EFI和iBoot/">引导过程：EFI和iBoot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是引导过程"><a href="#什么是引导过程" class="headerlink" title="什么是引导过程"></a>什么是引导过程</h2><p>引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：</p>
<ol>
<li>刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。</li>
<li>接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到<code>操作系统加载器</code>。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。</li>
<li>由操作系统加载器加载操作系统代码。</li>
</ol>
<h2 id="EFI（Extensible-Firmware-Interface，可扩展固件接口）"><a href="#EFI（Extensible-Firmware-Interface，可扩展固件接口）" class="headerlink" title="EFI（Extensible Firmware Interface，可扩展固件接口）"></a>EFI（Extensible Firmware Interface，可扩展固件接口）</h2><h3 id="BIOS的局限性"><a href="#BIOS的局限性" class="headerlink" title="BIOS的局限性"></a>BIOS的局限性</h3><ul>
<li>BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。</li>
<li>只允许4个可引导分区（或称为主分区）。</li>
</ul>
<h3 id="EFI的概念"><a href="#EFI的概念" class="headerlink" title="EFI的概念"></a>EFI的概念</h3><p>正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。</p>
<blockquote>
<p>EFI自下而上的架构大概是：硬件-&gt;固件（包含：EFI引导服务和EFI运行时服务）-&gt;EFI二进制文件（EFI引导加载器）-&gt;软件</p>
</blockquote>
<h3 id="EFI提供的服务"><a href="#EFI提供的服务" class="headerlink" title="EFI提供的服务"></a>EFI提供的服务</h3><h4 id="EFI引导服务"><a href="#EFI引导服务" class="headerlink" title="EFI引导服务"></a>EFI引导服务</h4><p>当系统仍然在EFI环境中，并且没有调用<code>ExitBootServices()</code>这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了<code>ExitBootServices()</code>,引导服务就无法访问了。</p>
<p>对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：</p>
<ul>
<li><strong>控制台协议</strong>（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）</li>
<li><strong>媒介访问</strong>（和文件系统打交道）</li>
<li><strong>杂项协议</strong>（）</li>
</ul>
<h4 id="EFI运行时服务"><a href="#EFI运行时服务" class="headerlink" title="EFI运行时服务"></a>EFI运行时服务</h4><p>跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：</p>
<ul>
<li>时间管理</li>
<li>闹钟</li>
<li>固件变量</li>
<li>其他杂项</li>
</ul>
<h2 id="OS-X的boot-efi"><a href="#OS-X的boot-efi" class="headerlink" title="OS X的boot.efi"></a>OS X的boot.efi</h2><ol>
<li>调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。</li>
<li>引导内核，EFI引导服务退出。</li>
<li>内核回调EFI运行时服务。</li>
</ol>
<h2 id="iOS的iBoot"><a href="#iOS的iBoot" class="headerlink" title="iOS的iBoot"></a>iOS的iBoot</h2><p>iOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：</p>
<ul>
<li><strong>普通引导、恢复模式引导</strong></li>
<li><strong>DFU模式引导</strong></li>
</ul>
<p><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true" alt="图1"></p>
<p>整个引导过程大概是这样的：</p>
<ol>
<li>首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)</li>
<li>接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。</li>
<li>普通引导或恢复模式引导：<ul>
<li>加载LLB（Low level Bootloader，底层引导加载器。</li>
<li>加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 </li>
</ul>
</li>
<li>DFU模式引导，使用了两个镜像iBSS和iBEC。<ul>
<li>iBSS：负责底层初始化以及iBEC的加载。</li>
<li>iBEC：负责iTunes通过USB升级的过程。</li>
</ul>
</li>
</ol>
<h3 id="普通引导或恢复模式引导"><a href="#普通引导或恢复模式引导" class="headerlink" title="普通引导或恢复模式引导"></a>普通引导或恢复模式引导</h3><h4 id="LLB"><a href="#LLB" class="headerlink" title="LLB"></a>LLB</h4><p>它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。</p>
<h4 id="iBoot"><a href="#iBoot" class="headerlink" title="iBoot"></a>iBoot</h4><p>iBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：</p>
<ul>
<li><strong>“main”线程</strong>，负责苹果的logo，以及系统的引导。</li>
<li><strong>“uart reader”线程</strong>，这个线程用户调试用。</li>
</ul>
<p>正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入<strong>恢复模式</strong>，main线程会派生几下几个任务：</p>
<ul>
<li><strong>idleoff任务</strong>，当用户不操作时，关闭设备。</li>
<li><strong>poweroff任务</strong>，当电量不足的时候，关闭设备。</li>
<li><strong>usb-req任务</strong>，处理iTunes的USB请求。</li>
<li><strong>usb-high-current和usb-no-current任务</strong>，响应USB充电。（当设备充电或者断开充电，修改电池图标）</li>
<li><strong>command任务</strong>,启动命令行接口，即通过串口操作的控制台。</li>
</ul>
<h4 id="恢复模式引导与普通引导的区别"><a href="#恢复模式引导与普通引导的区别" class="headerlink" title="恢复模式引导与普通引导的区别"></a>恢复模式引导与普通引导的区别</h4><p>恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。</p>
<h3 id="DFU模式引导"><a href="#DFU模式引导" class="headerlink" title="DFU模式引导"></a>DFU模式引导</h3><p>再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。</p>
<h2 id="OS-X的安装过程"><a href="#OS-X的安装过程" class="headerlink" title="OS X的安装过程"></a>OS X的安装过程</h2><h3 id="步骤1：installXXX-app"><a href="#步骤1：installXXX-app" class="headerlink" title="步骤1：installXXX.app"></a>步骤1：installXXX.app</h3><p>安装包包含的文件如下图所示：<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true" alt="图2"><br>运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作<code>根文件系统</code>的镜像–BaseSystem.dmg，然后通过<code>bless</code>命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。</p>
<h3 id="步骤2：OSInstaller"><a href="#步骤2：OSInstaller" class="headerlink" title="步骤2：OSInstaller"></a>步骤2：OSInstaller</h3><p>引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。</p>
<h3 id="步骤3：安装-pkg文件"><a href="#步骤3：安装-pkg文件" class="headerlink" title="步骤3：安装.pkg文件"></a>步骤3：安装.pkg文件</h3><p>最后就是安装各种各样的软件包了。</p>
<h2 id="iOS文件系统镜像（-ipsw文件）"><a href="#iOS文件系统镜像（-ipsw文件）" class="headerlink" title="iOS文件系统镜像（.ipsw文件）"></a>iOS文件系统镜像（.ipsw文件）</h2><p>将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。<br><img src="https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/ipsw.png?raw=true" alt="图3"></p>
<blockquote>
<p>可以使用工具<a href="http://theiphonewiki.com/" target="_blank" rel="external">wpwntool</a>解密文件，使用<a href="http://theiphonewiki.com/" target="_blank" rel="external">vfdecrypt</a>解密系统镜像。</p>
</blockquote>
<hr>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/01/引导过程：EFI和iBoot/" class="archive-article-date">
  	<time datetime="2016-09-01T01:17:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-01</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/引导过程/">引导过程</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a><a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Mach调度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/Mach调度/">Mach调度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是个结构体</p>
<h2 id="任务（task）"><a href="#任务（task）" class="headerlink" title="任务（task）"></a>任务（task）</h2><p>线程的容器，是以线程为元素的数组</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h2 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h2><p>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>
<h2 id="续体"><a href="#续体" class="headerlink" title="续体"></a>续体</h2><p>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>
<h2 id="抢占模式"><a href="#抢占模式" class="headerlink" title="抢占模式"></a>抢占模式</h2><ul>
<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>
<li>隐式抢占：调度器管理线程的执行。<h2 id="异步软件陷阱（AST）"><a href="#异步软件陷阱（AST）" class="headerlink" title="异步软件陷阱（AST）"></a>异步软件陷阱（AST）</h2></li>
</ul>
<h2 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h2><p>软件定时器：<br>硬件定时器：</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>
<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/30/Mach调度/" class="archive-article-date">
  	<time datetime="2016-08-30T02:12:09.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mach/">Mach</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a><a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-文件系统和虚拟文件系统交换（VFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/文件系统和虚拟文件系统交换（VFS）/">文件系统和虚拟文件系统交换（VFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h2><h3 id="主引导记录（Master-Boot-Record，MBR）"><a href="#主引导记录（Master-Boot-Record，MBR）" class="headerlink" title="主引导记录（Master Boot Record，MBR）"></a>主引导记录（Master Boot Record，MBR）</h3><ul>
<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>
</ul>
<h3 id="Apple-Partion-Map"><a href="#Apple-Partion-Map" class="headerlink" title="Apple Partion Map"></a>Apple Partion Map</h3><ul>
<li>32位方案，突破了4个分区的限制</li>
</ul>
<h3 id="GUID分区表（GUID-Partion-Table，GPT）"><a href="#GUID分区表（GUID-Partion-Table，GPT）" class="headerlink" title="GUID分区表（GUID Partion Table，GPT）"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>
<li>64位方案</li>
</ul>
<h2 id="软链接与硬链接"><a href="#软链接与硬链接" class="headerlink" title="软链接与硬链接"></a>软链接与硬链接</h2><ul>
<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>
<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>
<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/30/文件系统和虚拟文件系统交换（VFS）/" class="archive-article-date">
  	<time datetime="2016-08-30T02:11:37.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文件系统/">文件系统</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a><a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-React Native笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/React Native笔记/">React Native笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="要点记录"><a href="#要点记录" class="headerlink" title="要点记录"></a>要点记录</h2><h3 id="本地模块（Native-Modules）"><a href="#本地模块（Native-Modules）" class="headerlink" title="本地模块（Native Modules）"></a>本地模块（<a href="http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules" target="_blank" rel="external">Native Modules</a>）</h3><ul>
<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>
<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">dispatch_queue_t</span>)methodQueue</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> dispatch_queue_create(<span class="string">"com.facebook.React.AsyncLocalStorageQueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class="built_in">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class="line">&#123; </div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// Call long-running code on background thread</span></div><div class="line">    ...</div><div class="line">    <span class="comment">// You can invoke callback from any thread/queue</span></div><div class="line">    callback(@[...]);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RCTBridge.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RCTEventDispatcher.h"</span></span></div><div class="line">@(开发笔记)implementation CalendarManager</div><div class="line"></div><div class="line"><span class="keyword">@synthesize</span> bridge = _bridge;</div><div class="line">- (<span class="keyword">void</span>)calendarEventReminderReceived:(<span class="built_in">NSNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">  <span class="built_in">NSString</span> *eventName = notification.userInfo[<span class="string">@"name"</span>];</div><div class="line">  [<span class="keyword">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class="string">@"EventReminder"</span> body:@&#123;<span class="string">@"name"</span>: eventName&#125;];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>JavaScript订阅事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; NativeAppEventEmitter &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"><span class="keyword">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class="line">  <span class="string">'EventReminder'</span>,</div><div class="line">  (reminder) =&gt; <span class="built_in">console</span>.log(reminder.name)</div><div class="line">);</div><div class="line">...</div><div class="line"><span class="comment">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class="line">subscription.remove();</div></pre></td></tr></table></figure></p>
<h2 id="本地UI组件（Native-UI-Components"><a href="#本地UI组件（Native-UI-Components" class="headerlink" title="本地UI组件（Native UI Components)"></a>本地UI组件（<a href="http://facebook.github.io/react-native/docs/native-components-ios.html#content" target="_blank" rel="external">Native UI Components</a>)</h2><ul>
<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class="line">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class="line">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class="line">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>
</li>
<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCTMapManager</span></span></div><div class="line"></div><div class="line">RCT_EXPORT_MODULE()</div><div class="line"></div><div class="line">- (<span class="built_in">UIView</span> *)view</div><div class="line">&#123;</div><div class="line">  RCTMap *map = [RCTMap new];</div><div class="line">  map.delegate = <span class="keyword">self</span>;</div><div class="line">  <span class="keyword">return</span> map;</div><div class="line">&#125;</div><div class="line"></div><div class="line">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class="built_in">BOOL</span>)</div><div class="line">RCT_CUSTOM_VIEW_PROPERTY(region, <span class="built_in">MKCoordinateRegion</span>, RCTMap)</div><div class="line">&#123;</div><div class="line">  [view setRegion:json ? [RCTConvert <span class="built_in">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class="literal">YES</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后在JavaScript中就可以这一样使用了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MapView.js</span></div><div class="line"><span class="keyword">import</span> &#123; requireNativeComponent &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"><span class="comment">//requireNativeComponent automatically resolves this to "RCTMapManager"</span></div><div class="line">&lt;RCTMap showsUserLocation=&#123;<span class="literal">false</span>&#125; /&gt;</div><div class="line"><span class="built_in">module</span>.exports = requireNativeComponent(<span class="string">'RCTMap'</span>, <span class="literal">null</span>);</div></pre></td></tr></table></figure></p>
<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MapView.js</span></div><div class="line"><span class="keyword">import</span> React, &#123; requireNativeComponent &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MapView.propTypes = &#123;</div><div class="line">  /**</div><div class="line">   * When this property is set to `true` and a valid camera is associated</div><div class="line">   * with the map, the camera’s pitch angle is used to tilt the plane</div><div class="line">   * of the map. When this property is set to `false`, the camera’s pitch</div><div class="line">   * angle is ignored and the map is always displayed as if the user</div><div class="line">   * is looking straight down onto it.</div><div class="line">   */</div><div class="line">  pitchEnabled: React.PropTypes.bool,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class="line"></div><div class="line">module.exports = MapView;</div></pre></td></tr></table></figure>
<h2 id="FLUX"><a href="#FLUX" class="headerlink" title="FLUX"></a>FLUX</h2><p><strong>MVC模式</strong>：</p>
<ul>
<li>Facebok 眼中的MVC<br><img src="http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Facebok 眼中的MVC"></li>
<li>网友眼中的MVC<br><img src="http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网友眼中的MVC"></li>
</ul>
<p><strong>FLUX</strong>数据模型：（<a href="https://github.com/facebook/flux/）">https://github.com/facebook/flux/）</a><br><img src="http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FLUX"></p>
<ul>
<li>Action:</li>
<li>Dispatcher:</li>
<li>Store:</li>
<li>View:</li>
</ul>
<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>
<p><strong>FLUX与MVC的区别</strong></p>
<ul>
<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>
</ul>
<h2 id="ES6语法相关"><a href="#ES6语法相关" class="headerlink" title="ES6语法相关"></a>ES6语法相关</h2><ul>
<li><a href="https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md"><strong>module</strong></a></li>
</ul>
<ol>
<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
<li>循环加载问题，commonJS跟ES6的区别。</li>
</ol>
<ul>
<li><a href="https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数">异步操作和Async函数</a></li>
</ul>
<ol>
<li><a href="https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise">Promise</a></li>
<li><a href="https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>
<li><a href="https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>
<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href="https://github.com/tj/co">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>
<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>
</blockquote>
</li>
<li><a href="https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>
</ol>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>
<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>
<li>ReactNative增量升级方案 <a href="http://react-china.org/t/reactnative/3932" target="_blank" rel="external">http://react-china.org/t/reactnative/3932</a></li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/30/React Native笔记/" class="archive-article-date">
  	<time datetime="2016-08-30T02:10:53.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JS/">JS</a><a class="article-category-link" href="/categories/JS/React-Native/">React Native</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-网络七层协议（结合操作系统来了解）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/网络七层协议（结合操作系统来了解）/">网络七层协议（结合操作系统来了解）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h2><h3 id="第7层：应用层"><a href="#第7层：应用层" class="headerlink" title="第7层：应用层"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>
<h3 id="第6层：表示层"><a href="#第6层：表示层" class="headerlink" title="第6层：表示层"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>
<h3 id="第5层：会话层"><a href="#第5层：会话层" class="headerlink" title="第5层：会话层"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct socket &#123;</div><div class="line">    ...</div><div class="line">    void *so_pcb;           //协议控制块</div><div class="line">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class="line">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class="line">                        so_send; //发送队列</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h2><h3 id="第4层：传输层"><a href="#第4层：传输层" class="headerlink" title="第4层：传输层"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>
<h3 id="第3层：网络层"><a href="#第3层：网络层" class="headerlink" title="第3层：网络层"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>
<h3 id="第2层：数据链路层"><a href="#第2层：数据链路层" class="headerlink" title="第2层：数据链路层"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>
<p>##硬件</p>
<h3 id="第1层：物理层"><a href="#第1层：物理层" class="headerlink" title="第1层：物理层"></a>第1层：物理层</h3><p>  硬件相关</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/30/网络七层协议（结合操作系统来了解）/" class="archive-article-date">
  	<time datetime="2016-08-30T02:09:57.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a><a class="article-category-link" href="/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/">深入解析Mac OS X && iOS操作系统笔记</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-H5的体验优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/H5的体验优化/">H5的体验优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="H5跟Native的性能对比"><a href="#H5跟Native的性能对比" class="headerlink" title="H5跟Native的性能对比"></a>H5跟Native的性能对比</h2><ul>
<li>native可以做缓存，第二次访问可以实现秒开。</li>
<li>对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。</li>
<li>webView的加载需要耗时，网络建立连接也需要时间。</li>
</ul>
<h2 id="未采用的优化H5的方案"><a href="#未采用的优化H5的方案" class="headerlink" title="未采用的优化H5的方案"></a>未采用的优化H5的方案</h2><ul>
<li>离线包+预加载。<br>缺点：</li>
</ul>
<ol>
<li>主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。</li>
<li>离线包发布效率低下。</li>
<li>由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。</li>
</ol>
<h2 id="比较好的优化方案"><a href="#比较好的优化方案" class="headerlink" title="比较好的优化方案"></a>比较好的优化方案</h2><ol>
<li>由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。</li>
<li>将HTTP改成了Socket。</li>
<li>通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。</li>
</ol>
<h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><ol>
<li>H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。</li>
<li>模板也需要制定一套更新的机制。</li>
</ol>
<h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><ul>
<li>针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。</li>
</ul>
<p>要点提炼自：<a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993637&amp;idx=1&amp;sn=8a2673272575abbef4b0f6dbc25e0186&amp;scene=0#wechat_redirect" target="_blank" rel="external">QQ空间面向移动时代Hybrid架构设计</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/30/H5的体验优化/" class="archive-article-date">
  	<time datetime="2016-08-30T02:04:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/H5/">H5</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Web/">Web</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-创建pod库的步骤" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/创建pod库的步骤/">创建pod库的步骤</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="标签（空格分隔）：-开发-iOS"><a href="#标签（空格分隔）：-开发-iOS" class="headerlink" title="标签（空格分隔）： 开发 iOS"></a>标签（空格分隔）： 开发 iOS</h2><h2 id="注册Trunk"><a href="#注册Trunk" class="headerlink" title="注册Trunk"></a>注册Trunk</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure>
<h2 id="验证邮箱"><a href="#验证邮箱" class="headerlink" title="验证邮箱"></a>验证邮箱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk me</div></pre></td></tr></table></figure>
<h2 id="push源码到git仓库"><a href="#push源码到git仓库" class="headerlink" title="push源码到git仓库"></a>push源码到git仓库</h2><h2 id="创建podspec文件"><a href="#创建podspec文件" class="headerlink" title="创建podspec文件"></a>创建podspec文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure>
<h2 id="编辑podspec文件"><a href="#编辑podspec文件" class="headerlink" title="编辑podspec文件"></a>编辑podspec文件</h2><h2 id="检查podspec文件格式是否符合规则"><a href="#检查podspec文件格式是否符合规则" class="headerlink" title="检查podspec文件格式是否符合规则"></a>检查podspec文件格式是否符合规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint --no-clean</div></pre></td></tr></table></figure>
<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>
<h2 id="使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库"><a href="#使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库" class="headerlink" title="使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库"></a>使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure>
<h2 id="成功后pod-setup"><a href="#成功后pod-setup" class="headerlink" title="成功后pod setup"></a>成功后<code>pod setup</code></h2><h2 id="验证是否成功："><a href="#验证是否成功：" class="headerlink" title="验证是否成功："></a>验证是否成功：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/30/创建pod库的步骤/" class="archive-article-date">
  	<time datetime="2016-08-30T02:02:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocoapods/">Cocoapods</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a><a class="article-category-link" href="/categories/Apple-Development/iOS开发笔记/">iOS开发笔记</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-iOS签名" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/iOS签名/">iOS签名</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="签名证书（开发者证书）生成过程"><a href="#签名证书（开发者证书）生成过程" class="headerlink" title="签名证书（开发者证书）生成过程"></a>签名证书（开发者证书）生成过程</h2><ul>
<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>
<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>
</ul>
<h2 id="授权描述文件（provisioning-profile）"><a href="#授权描述文件（provisioning-profile）" class="headerlink" title="授权描述文件（provisioning profile）"></a>授权描述文件（provisioning profile）</h2><ul>
<li>AppID</li>
<li>哪些证书合法</li>
<li>哪些设备(UUID)可以运行</li>
<li>拥有哪些特权</li>
<li>苹果的签名<blockquote>
<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>
</blockquote>
</li>
</ul>
<p>##授权文件（entitlements）</p>
<ul>
<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="app重签流程"><a href="#app重签流程" class="headerlink" title="app重签流程"></a>app重签流程</h2><ul>
<li>首先解压ipa</li>
<li>如果mobileprovision需要替换，替换</li>
<li></li>
<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>
<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>
<li>重新打包</li>
</ul>
<h2 id="签名相关命令"><a href="#签名相关命令" class="headerlink" title="签名相关命令"></a>签名相关命令</h2><ul>
<li><p>解压ipa包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>找出本机可以用来签名的证书信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>
</li>
<li><p>列出app使用的签名信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>
</li>
<li><p>查看entitlement.plist</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>
</li>
<li><p>对app重签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>
</li>
<li><p>检验签名是否合法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codesign -v xxx.app</div></pre></td></tr></table></figure>
</li>
<li><p>重新打包ipa包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zip -qry destination source</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>参考文章：<br><a href="https://segmentfault.com/a/1190000004144556" target="_blank" rel="external">漫谈iOS程序的证书和签名机制</a><br><a href="https://github.com/maciekish/iReSign">iReSign</a><br><a href="https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7" target="_blank" rel="external">re-sign-ios-app</a><br><a href="http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/" target="_blank" rel="external">iOS Code Signing 学习笔记</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/30/iOS签名/" class="archive-article-date">
  	<time datetime="2016-08-30T02:01:06.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全/">安全</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Apple-Development/">Apple Development</a><a class="article-category-link" href="/categories/Apple-Development/安全/">安全</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 EA88
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Cocoapods/" style="font-size: 10px;">Cocoapods</a> <a href="/tags/CoreText/" style="font-size: 10px;">CoreText</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/Mach/" style="font-size: 20px;">Mach</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/XNU/" style="font-size: 10px;">XNU</a> <a href="/tags/launchd/" style="font-size: 10px;">launchd</a> <a href="/tags/事件响应链/" style="font-size: 10px;">事件响应链</a> <a href="/tags/内核/" style="font-size: 10px;">内核</a> <a href="/tags/内核架构/" style="font-size: 10px;">内核架构</a> <a href="/tags/学习方法/" style="font-size: 15px;">学习方法</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/引导过程/" style="font-size: 10px;">引导过程</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>